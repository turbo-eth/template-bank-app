{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // â†’ `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // â†’ `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/Assets.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { OwnedThreeStep } from \"./Solbase/OwnedThreeStep.sol\";\n\ncontract Web3Assets is OwnedThreeStep {\n  mapping(bytes32 => string) private assets;\n\n  /* ===================================================================================== */\n  /* Constructor & Modifiers                                                               */\n  /* ===================================================================================== */\n\n  constructor(address _owner) OwnedThreeStep(_owner) {}\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n\n  function get(bytes32 position) external view returns (string memory) {\n    return assets[position];\n  }\n\n  function decode(bytes memory input) external view returns (string memory) {\n    bytes32 position = abi.decode(input, (bytes32));\n    return assets[position];\n  }\n\n  function set(bytes32 position, string memory svg) external onlyOwner {\n    assets[position] = svg;\n  }\n}\n"
    },
    "contracts/Card.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20TWAB } from \"./PoolTogether/ERC20TWAB.sol\";\nimport { ISVGRender } from \"./ERC721K/interfaces/ISVGRender.sol\";\nimport { ERC721K } from \"./ERC721K/ERC721K.sol\";\nimport { ERC721Storage } from \"./ERC721K/ERC721Storage.sol\";\nimport { CardStorage } from \"./CardStorage.sol\";\n\ncontract Card is ERC721K {\n  uint256 private immutable CONTROLLER_ROLE = 1e18;\n\n  mapping(address => uint256) private _belongsTo;\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    address erc721Storage\n  ) ERC721K(name, symbol, erc721Storage) {\n    _idCounter++;\n  }\n\n  /* ===================================================================================== */\n  /* Override Functions                                                                    */\n  /* ===================================================================================== */\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(ERC721K)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n\n  function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n    address owner = _ownerOf[tokenId];\n    if (owner == address(0)) {\n      return address(0);\n    }\n    return owner;\n  }\n\n  function belongsTo(address account) public view virtual returns (uint256) {\n    return _belongsTo[account];\n  }\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n\n  // --------------------------------------\n  // READS\n  // --------------------------------------\n\n  function preview(address account) external view returns (string memory) {\n    bytes memory imageBytes = CardStorage(_erc721Storage).getPreview(account);\n    return ISVGRender(ERC721Storage(_erc721Storage).getERC721KRender()).render(imageBytes);\n  }\n\n  function previewWithStyle(\n    address account,\n    uint8 color,\n    uint8 emoji\n  ) external view returns (string memory) {\n    bytes memory imageBytes = CardStorage(_erc721Storage).getPreviewWithStyle(\n      account,\n      color,\n      emoji\n    );\n    return ISVGRender(ERC721Storage(_erc721Storage).getERC72KTraits()).render(imageBytes);\n  }\n\n  // --------------------------------------\n  // WRITES\n  // --------------------------------------\n\n  /**\n   * @notice Mints a new token to the given address\n   * @param to address - Address to mint to`\n   */\n  function mint(address to) external returns (uint256) {\n    require(hasAllRoles(msg.sender, CONTROLLER_ROLE), \"Web3Card:unauthorized\");\n    require(_belongsTo[to] == 0, \"Web3Card:activated\");\n    uint256 nextId;\n    unchecked {\n      nextId = _idCounter++;\n      _belongsTo[to] = nextId;\n      _mint(to, nextId);\n    }\n    return nextId;\n  }\n\n  /**\n   * @notice Burns a token\n   * @param tokenId uint256 - Token ID to burn\n   */\n  function burn(uint256 tokenId) external {\n    require(hasAllRoles(msg.sender, CONTROLLER_ROLE), \"Web3Card:unauthorized\");\n    address owner = ownerOf(tokenId);\n    _belongsTo[owner] = 0;\n    _burn(tokenId);\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public virtual override {\n    _belongsTo[from] = 0;\n    _belongsTo[to] = tokenId;\n    super.transferFrom(from, to, tokenId);\n  }\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public virtual override {\n    _belongsTo[from] = 0;\n    _belongsTo[to] = tokenId;\n    super.safeTransferFrom(from, to, tokenId);\n  }\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) public virtual override {\n    _belongsTo[from] = 0;\n    _belongsTo[to] = tokenId;\n    super.safeTransferFrom(from, to, tokenId, data);\n  }\n\n  /* ===================================================================================== */\n  /* Internal Functions                                                                    */\n  /* ===================================================================================== */\n\n  function _tokenData(uint256 _tokenId)\n    internal\n    view\n    virtual\n    override\n    returns (bytes memory, bytes memory)\n  {\n    bytes memory imageBytes = CardStorage(_erc721Storage).getImageBytes(_tokenId);\n    bytes memory traitsBytes = CardStorage(_erc721Storage).getTraitsBytes(_tokenId);\n    return (imageBytes, traitsBytes);\n  }\n}\n"
    },
    "contracts/CardActivator.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Owned } from \"./Solbase/Owned.sol\";\nimport { Card } from \"./Card.sol\";\nimport { CardDesign } from \"./CardDesign.sol\";\n\ncontract CardActivator is Owned {\n  address public erc721KInstance;\n  address public erc721KDesignInstance;\n\n  uint256 private STYLE_UPGRADE_VALUE = 0.01 ether;\n\n  constructor(\n    address admin,\n    address _erc721KInstance,\n    address _erc721KDesignInstance\n  ) Owned(admin) {\n    erc721KInstance = _erc721KInstance;\n    erc721KDesignInstance = _erc721KDesignInstance;\n  }\n\n  function activate(address to) external {\n    Card(erc721KInstance).mint(to);\n  }\n\n  function activateWithStyle(\n    address to,\n    uint8 color,\n    uint8 emoji\n  ) external payable {\n    if (color + emoji >= 1)\n      require(msg.value >= STYLE_UPGRADE_VALUE, \"Web3CardActivator:insufficient-eth\");\n    uint256 tokenId_ = Card(erc721KInstance).mint(to);\n    CardDesign(erc721KDesignInstance).setDuringMint(tokenId_, color, emoji);\n  }\n\n  function release(uint256 value) external onlyOwner {\n    (bool _success, ) = msg.sender.call{ value: value }(\"\");\n    require(_success, \"Web3CardActivator:eth-release-failed\");\n  }\n\n  function setStyleUpgradeCost(uint256 value) external onlyOwner {\n    STYLE_UPGRADE_VALUE = value;\n  }\n}\n"
    },
    "contracts/CardDesign.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"./Solbase/ERC721.sol\";\nimport { OwnedThreeStep } from \"./Solbase/OwnedThreeStep.sol\";\n\ncontract CardDesign is OwnedThreeStep {\n  address public erc721KActivatorInstance;\n\n  uint256 private STYLE_UPGRADE_VALUE = 0.01 ether;\n\n  mapping(uint256 => uint8) private _color;\n  mapping(uint256 => uint8) private _emoji;\n\n  mapping(uint8 => bytes) private _colorMap;\n  mapping(uint8 => string) private _emojiMap;\n\n  mapping(address => bool) private _supporter;\n\n  /* ===================================================================================== */\n  /* Constructor & Modifiers                                                               */\n  /* ===================================================================================== */\n\n  constructor(address _owner) OwnedThreeStep(_owner) {\n    _colorMap[0] = hex\"6236C5\"; // Purple\n    _colorMap[1] = hex\"224396\"; // Blue\n    _colorMap[2] = hex\"922B2B\"; // Red\n    _colorMap[3] = hex\"498933\"; // Green\n    _colorMap[4] = hex\"313131\"; // Black\n\n    _emojiMap[0] = unicode\"ðŸ¦\";\n    _emojiMap[1] = unicode\"ðŸ¦œ\";\n    _emojiMap[2] = unicode\"ðŸ¦Š\";\n    _emojiMap[3] = unicode\"ðŸ¦„\";\n    _emojiMap[4] = unicode\"ðŸ™\";\n    _emojiMap[5] = unicode\"ðŸµ\";\n    _emojiMap[6] = unicode\"ðŸ³\";\n    _emojiMap[7] = unicode\"ðŸ\";\n    _emojiMap[8] = unicode\"ðŸº\";\n    _emojiMap[9] = unicode\"ðŸ‘‘\";\n    _emojiMap[10] = unicode\"ðŸš€\";\n    _emojiMap[11] = unicode\"ðŸŒˆ\";\n    _emojiMap[12] = unicode\"ðŸª¶\";\n    _emojiMap[13] = unicode\"ðŸ§¸\";\n    _emojiMap[14] = unicode\"ðŸŽ\";\n    _emojiMap[15] = unicode\"ðŸ’Œ\";\n    _emojiMap[16] = unicode\"ðŸŽ€\";\n    _emojiMap[17] = unicode\"ðŸ”®\";\n    _emojiMap[18] = unicode\"ðŸ’Ž\";\n    _emojiMap[19] = unicode\"ðŸª…\";\n    _emojiMap[20] = unicode\"ðŸ—\";\n    _emojiMap[21] = unicode\"ðŸ§°\";\n    _emojiMap[22] = unicode\"ðŸ§²\";\n    _emojiMap[23] = unicode\"ðŸ§ª\";\n    _emojiMap[24] = unicode\"ðŸ›¡ï¸\";\n    _emojiMap[25] = unicode\"ðŸ§¬\";\n    _emojiMap[26] = unicode\"ðŸ§­\";\n    _emojiMap[27] = unicode\"ðŸ§®\";\n    _emojiMap[28] = unicode\"âš”ï¸\";\n    _emojiMap[29] = unicode\"ðŸ§°\";\n    _emojiMap[30] = unicode\"ðŸ§±\";\n    _emojiMap[31] = unicode\"â›“ï¸\";\n    _emojiMap[32] = unicode\"ðŸˆ\";\n    _emojiMap[33] = unicode\"ðŸ€\";\n    _emojiMap[34] = unicode\"âš½ï¸\";\n    _emojiMap[35] = unicode\"ðŸ\";\n    _emojiMap[36] = unicode\"ðŸ“\";\n    _emojiMap[37] = unicode\"ðŸŽ¾\";\n    _emojiMap[38] = unicode\"ðŸŽ²\";\n    _emojiMap[39] = unicode\"ðŸ‰\";\n    _emojiMap[40] = unicode\"ðŸŽ½\";\n    _emojiMap[41] = unicode\"ðŸ†\";\n    _emojiMap[42] = unicode\"ðŸŽ¯\";\n  }\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n\n  function getEmoji(uint256 tokenId) external view returns (string memory) {\n    return _emojiMap[_emoji[tokenId]];\n  }\n\n  function getColor(uint256 tokenId) external view returns (bytes memory) {\n    return _colorMap[_color[tokenId]];\n  }\n\n  function getEmojiFromMap(uint8 emojiId) external view returns (string memory) {\n    return _emojiMap[emojiId];\n  }\n\n  function getColorFromMap(uint8 colorId) external view returns (bytes memory) {\n    return _colorMap[colorId];\n  }\n\n  function setDuringMint(\n    uint256 tokenId,\n    uint8 color,\n    uint8 emoji\n  ) external {\n    require(msg.sender == erc721KActivatorInstance, \"Web3CardDesign:not-authorized\");\n    _color[tokenId] = color;\n    _emoji[tokenId] = emoji;\n  }\n\n  function setEmoji(uint256 tokenId, uint8 emoji) external payable {\n    require(msg.value >= STYLE_UPGRADE_VALUE, \"Web3CardDesign:insufficient-eth\");\n    require(\n      msg.sender == ERC721(erc721KActivatorInstance).ownerOf(tokenId),\n      \"Web3CardDesign:not-owner\"\n    );\n    _emoji[tokenId] = emoji;\n    _call(msg.value);\n  }\n\n  function setColor(uint256 tokenId, uint8 color) external payable {\n    require(msg.value >= STYLE_UPGRADE_VALUE, \"Web3CardDesign:insufficient-eth\");\n    require(\n      msg.sender == ERC721(erc721KActivatorInstance).ownerOf(tokenId),\n      \"Web3CardDesign:not-owner\"\n    );\n    _color[tokenId] = color;\n    _call(msg.value);\n  }\n\n  function setERC721KActivatorInstance(address _erc721KActivatorInstance) external onlyOwner {\n    erc721KActivatorInstance = _erc721KActivatorInstance;\n  }\n\n  function setStyleUpgradeCost(uint256 _styleUpgradeCost) external onlyOwner {\n    STYLE_UPGRADE_VALUE = _styleUpgradeCost;\n  }\n\n  function _call(uint256 value) internal {\n    (bool _success, ) = erc721KActivatorInstance.call{ value: value }(\"\");\n    require(_success, \"Web3CardDesign:call-failed\");\n  }\n}\n"
    },
    "contracts/CardStorage.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { ERC721Storage } from \"./ERC721K/ERC721Storage.sol\";\nimport { ERC721 } from \"./Solbase/ERC721.sol\";\nimport { TwabLib } from \"./PoolTogether/twab/TwabLib.sol\";\nimport { ERC20TWAB } from \"./PoolTogether/ERC20TWAB.sol\";\nimport { CardDesign } from \"./CardDesign.sol\";\n\n/*\n * @title CardStorage\n * @author Kames Geraghty\n * @description CardStorge provides storage and rendering instriutions for the Card contract.\n */\ncontract CardStorage is ERC721Storage {\n  address public assetUnderlying;\n\n  /// Smart Contact Instance(s)\n  address public erc20TWABInstance;\n  address public erc721KInstance;\n  address public erc721KDesignInstance;\n\n  bytes private DEFAULT_COLOR = hex\"6236C5\";\n\n  mapping(uint256 => string) private _name;\n  mapping(uint256 => string) private _emojiMap;\n\n  constructor(\n    address _svgRender_,\n    address _traitsFetch_,\n    ContractURI memory _contractURI_,\n    address _erc20TWABInstance,\n    address _erc721KDesignInstance,\n    address _assetUnderlying\n  ) ERC721Storage(_svgRender_, _traitsFetch_, _contractURI_) {\n    erc20TWABInstance = _erc20TWABInstance;\n    erc721KDesignInstance = _erc721KDesignInstance;\n    assetUnderlying = _assetUnderlying;\n  }\n\n  struct RenderMetadata {\n    uint256 balance;\n    uint256 chance;\n    uint256 avgBalance2Weeks;\n    uint256 avgBalance8Weeks;\n    uint256 avgBalance26Weeks;\n    uint256 avgBalance52Weeks;\n    string emoji;\n    bytes color;\n  }\n\n  /// =====================================================================================\n  /// Override Functions\n  /// =====================================================================================\n  function _parseName(uint256 _tokenId) internal view override returns (string memory) {\n    return string.concat(\"Web3 Savings Card #\", Strings.toString(_tokenId));\n  }\n\n  function _parseDescription(uint256 _tokenId) internal view override returns (string memory) {\n    return \"Member of the Web3 Savings Network\";\n  }\n\n  /// =====================================================================================\n  /// External Functions\n  /// =====================================================================================\n\n  /// ===================================\n  /// Getters\n  /// ===================================\n\n  function getImageBytes(uint256 tokenId) external view returns (bytes memory) {\n    address account = ERC721(erc721KInstance).ownerOf(tokenId);\n    return _generateBytesData(tokenId, account);\n  }\n\n  function getTraitsBytes(uint256 tokenId) external view returns (bytes memory) {\n    address account = ERC721(erc721KInstance).ownerOf(tokenId);\n    return _generateBytesData(tokenId, account);\n  }\n\n  function getPreview(address account) external view returns (bytes memory imageData) {\n    return _generateBytesData(0, account);\n  }\n\n  function _generateBytesData(uint256 _tokenId, address account)\n    internal\n    view\n    returns (bytes memory bytesData)\n  {\n    uint256 balance;\n    TwabLib.AccountDetails memory accountDetails;\n    RenderMetadata memory renderMetadata;\n\n    renderMetadata.emoji = CardDesign(erc721KDesignInstance).getEmoji(_tokenId);\n    renderMetadata.color = CardDesign(erc721KDesignInstance).getColor(_tokenId);\n\n    if (bytes(renderMetadata.emoji).length == 0) {\n      renderMetadata.emoji = unicode\"ðŸ’³\";\n    }\n\n    if (renderMetadata.color.length == 0) {\n      renderMetadata.color = DEFAULT_COLOR;\n    }\n\n    if (erc20TWABInstance != address(0)) {\n      balance = ERC20TWAB(erc20TWABInstance).balanceOf(account);\n      accountDetails = ERC20TWAB(erc20TWABInstance).getAccountDetails(account);\n      /// Average Balances\n      uint64 end = uint64(block.timestamp);\n      renderMetadata.avgBalance2Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\n        account,\n        uint64(block.timestamp - 2 weeks),\n        end\n      );\n      renderMetadata.avgBalance8Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\n        account,\n        uint64(block.timestamp - 8 weeks),\n        end\n      );\n      renderMetadata.avgBalance26Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\n        account,\n        uint64(block.timestamp - 26 weeks),\n        end\n      );\n      renderMetadata.avgBalance52Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\n        account,\n        uint64(block.timestamp - 52 weeks),\n        end\n      );\n    }\n\n    bytesData = bytes(\n      abi.encode(\n        account,\n        assetUnderlying, // Underlying Asset\n        balance, /// Balance\n        accountDetails.balance, /// Balance + Delegations\n        renderMetadata.avgBalance2Weeks,\n        renderMetadata.avgBalance8Weeks,\n        renderMetadata.avgBalance26Weeks,\n        renderMetadata.avgBalance52Weeks,\n        renderMetadata.emoji,\n        renderMetadata.color\n      )\n    );\n  }\n\n  function getPreviewWithStyle(\n    address account,\n    uint8 color,\n    uint8 emoji\n  ) external view returns (bytes memory bytesData) {\n    uint256 balance;\n    TwabLib.AccountDetails memory accountDetails;\n    RenderMetadata memory renderMetadata;\n\n    renderMetadata.color = CardDesign(erc721KDesignInstance).getColorFromMap(color);\n    renderMetadata.emoji = CardDesign(erc721KDesignInstance).getEmojiFromMap(emoji);\n\n    if (bytes(renderMetadata.emoji).length == 0) {\n      renderMetadata.emoji = unicode\"ðŸ’³\";\n    }\n\n    if (renderMetadata.color.length == 0) {\n      renderMetadata.color = DEFAULT_COLOR;\n    }\n\n    if (erc20TWABInstance != address(0)) {\n      balance = ERC20TWAB(erc20TWABInstance).balanceOf(account);\n      accountDetails = ERC20TWAB(erc20TWABInstance).getAccountDetails(account);\n      /// Average Balances\n      uint64 end = uint64(block.timestamp);\n      renderMetadata.avgBalance2Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\n        account,\n        uint64(block.timestamp - 2 weeks),\n        end\n      );\n      renderMetadata.avgBalance8Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\n        account,\n        uint64(block.timestamp - 8 weeks),\n        end\n      );\n      renderMetadata.avgBalance26Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\n        account,\n        uint64(block.timestamp - 26 weeks),\n        end\n      );\n      renderMetadata.avgBalance52Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\n        account,\n        uint64(block.timestamp - 52 weeks),\n        end\n      );\n    }\n\n    bytesData = bytes(\n      abi.encode(\n        account,\n        assetUnderlying, // Underlying Asset\n        balance, /// Balance\n        accountDetails.balance, /// Balance + Delegations\n        renderMetadata.avgBalance2Weeks,\n        renderMetadata.avgBalance8Weeks,\n        renderMetadata.avgBalance26Weeks,\n        renderMetadata.avgBalance52Weeks,\n        renderMetadata.emoji,\n        renderMetadata.color\n      )\n    );\n  }\n\n  /// ===================================\n  /// Setters\n  /// ===================================\n\n  function setERC721KInstance(address _erc721KInstance) external onlyOwner {\n    erc721KInstance = _erc721KInstance;\n  }\n\n  function setERC721KDesignInstance(address _erc721KDesignInstance) external onlyOwner {\n    erc721KDesignInstance = _erc721KDesignInstance;\n  }\n\n  function setERC20TWABInstance(address _erc20TWABInstance) external onlyOwner {\n    erc20TWABInstance = _erc20TWABInstance;\n  }\n\n  /// =====================================================================================\n  /// Internal Functions\n  /// =====================================================================================\n\n  function _getAverageBalance(\n    address _account,\n    uint64 _start,\n    uint64 _end\n  ) internal view returns (uint256) {\n    return ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(_account, _start, _end);\n  }\n}\n"
    },
    "contracts/CardTraits.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport { Owned } from \"./Solbase/Owned.sol\";\nimport { LibString } from \"./Solbase/LibString.sol\";\nimport { IStream } from \"./ERC721K/interfaces/IStream.sol\";\nimport { ITraitsFetch } from \"./ERC721K/interfaces/ITraitsFetch.sol\";\n\n/**\n * @title CardTraits\n * @author Kames Geraghty\n */\ncontract CardTraits is ITraitsFetch, Owned {\n  constructor() Owned(msg.sender) {}\n\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n\n  function fetch(bytes memory input) external view returns (string memory) {\n    (\n      address account,\n      address asset,\n      uint256 balance,\n      uint256 chance,\n      uint256 avgBalance2Weeks,\n      uint256 avgBalance8Weeks,\n      uint256 avgBalance26Weeks,\n      uint256 avgBalance52Weeks,\n      string memory emoji,\n      bytes32 color\n    ) = abi.decode(\n        input,\n        (address, address, uint256, uint256, uint256, uint256, uint256, uint256, string, bytes32)\n      );\n\n    string memory _account = LibString.toHexString(uint256(uint160(account)), 20);\n    string memory _asset = LibString.toHexString(uint256(uint160(asset)), 20);\n\n    return\n      string.concat(\n        _generateTrait(\"owner\", _account),\n        \",\",\n        _generateTrait(\"asset\", _asset),\n        \",\",\n        _generateTrait(\"balance\", LibString.toString(balance)),\n        \",\",\n        _generateTrait(\"chance\", LibString.toString(chance)),\n        \",\",\n        _generateTrait(\"avgBalance2Weeks\", LibString.toString(avgBalance2Weeks)),\n        \",\",\n        _generateTrait(\"avgBalance8Weeks\", LibString.toString(avgBalance8Weeks)),\n        \",\",\n        _generateTrait(\"avgBalance26Weeks\", LibString.toString(avgBalance26Weeks)),\n        \",\",\n        _generateTrait(\"avgBalance52Weeks\", LibString.toString(avgBalance52Weeks)),\n        \",\",\n        _generateTrait(\"emoji\", emoji)\n      );\n  }\n\n  /* ===================================================================================== */\n  /* Internal Functions                                                                    */\n  /* ===================================================================================== */\n\n  function _generateTrait(string memory _key, string memory _value)\n    internal\n    pure\n    returns (string memory __traits)\n  {\n    return string.concat('{\"trait_type\":' '\"', _key, '\",', '\"value\":', '\"', _value, '\"}');\n  }\n\n  function _generateTraits(string[] memory _keys, string[] memory _values)\n    internal\n    pure\n    returns (string memory __traits)\n  {\n    string memory _traits = \"\";\n    for (uint256 i = 0; i < _keys.length; i++) {\n      if (bytes(_values[i]).length > 0) {\n        _traits = string.concat(_traits, _generateTrait(_keys[i], _values[i]), \",\");\n      }\n    }\n    return _traits;\n  }\n}\n"
    },
    "contracts/ERC721K/ERC721K.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"../Solbase/ERC721.sol\";\nimport { OwnedRoles } from \"../Solbase/OwnedRoles.sol\";\nimport { ERC721Storage } from \"./ERC721Storage.sol\";\n\n/**\n * @title ERC721K\n * @author Kames Geraghty\n */\nabstract contract ERC721K is ERC721, OwnedRoles {\n  /// @notice ID counter for ERC721 tokens\n  uint256 internal _idCounter;\n\n  /// @notice ENSReverseRecords instance\n  address internal _erc721Storage;\n\n  event ERC721StorageUpdated(address erc721Storage);\n\n  /**\n   * @notice ERC721K Construction\n   * @param name_ string - Name of ERC721 token\n   * @param symbol_ string - Symbol of ERC721 token\n   * @param _erc721Storage_ address - Metadata instance\n   */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    address _erc721Storage_\n  ) ERC721(name_, symbol_) {\n    _erc721Storage = _erc721Storage_;\n    _initializeOwner(msg.sender);\n  }\n\n  /* ===================================================================================== */\n  /* EIP Functions                                                                     */\n  /* ===================================================================================== */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(ERC721)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n\n  /* ===================================================================================== */\n  /* Virtual Functions                                                                     */\n  /* ===================================================================================== */\n  function _tokenData(uint256 tokenId)\n    internal\n    view\n    virtual\n    returns (bytes memory imageBytes, bytes memory traitsBytes);\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n\n  function contractURI() external view returns (string memory) {\n    return ERC721Storage(_erc721Storage).constructContractURI();\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _idCounter;\n  }\n\n  function getERC721Storage() external view returns (address) {\n    return _erc721Storage;\n  }\n\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\n    (bytes memory imageBytes, bytes memory traitsBytes) = _tokenData(tokenId);\n    return ERC721Storage(_erc721Storage).constructTokenURI(tokenId, imageBytes, traitsBytes);\n  }\n\n  /* ====================================== */\n  /* Writes\n  /* ====================================== */\n\n  function setStorage(address erc721Storage) external onlyOwner {\n    _erc721Storage = erc721Storage;\n    emit ERC721StorageUpdated(erc721Storage);\n  }\n}\n"
    },
    "contracts/ERC721K/ERC721Storage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport { Base64 } from \"../Solbase/Base64.sol\";\nimport { OwnedRoles } from \"../Solbase/OwnedRoles.sol\";\nimport { IERC721KImage } from \"./interfaces/IERC721KImage.sol\";\nimport { IERC721KTraits } from \"./interfaces/IERC721KTraits.sol\";\n\n/**\n * @title ERC721Storage\n * @author Kames Geraghty\n */\nabstract contract ERC721Storage is OwnedRoles {\n  address internal svgRenderInstance;\n  address internal traitsFetchInstance;\n  ContractURI internal _contractURI;\n\n  struct ContractURI {\n    string name;\n    string description;\n    string image;\n    string externalLink;\n    string sellerFeeBasisPoints;\n    string feeRecipient;\n  }\n\n  event SvgRenderUpdated(address svgRender);\n\n  event TraitsFetchUpdated(address traitsFetch);\n\n  event ContractURIUpdated(ContractURI contractURI);\n\n  constructor(\n    address svgRender_Instance,\n    address traitsFetchInstance_,\n    ContractURI memory _contractURI_\n  ) OwnedRoles() {\n    svgRenderInstance = svgRender_Instance;\n    traitsFetchInstance = traitsFetchInstance_;\n    _contractURI = _contractURI_;\n    _initializeOwner(msg.sender);\n  }\n\n  /* ===================================================================================== */\n  /* Virtual Functions                                                                     */\n  /* ===================================================================================== */\n\n  function _parseName(uint256 _tokenId) internal view virtual returns (string memory);\n\n  function _parseDescription(uint256 _tokenId) internal view virtual returns (string memory);\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n  function getERC721KRender() external view returns (address) {\n    return svgRenderInstance;\n  }\n\n  function getERC72KTraits() external view returns (address) {\n    return traitsFetchInstance;\n  }\n\n  function getContractDescription() external view returns (ContractURI memory) {\n    return _contractURI;\n  }\n\n  function render(bytes memory input) external view returns (string memory) {\n    return IERC721KImage(svgRenderInstance).render(input);\n  }\n\n  function constructTokenURI(\n    uint256 tokenId,\n    bytes memory input0,\n    bytes memory input1\n  ) external view virtual returns (string memory uri) {\n    string memory image_ = IERC721KImage(svgRenderInstance).render(input0);\n    string memory traits_ = IERC721KTraits(traitsFetchInstance).fetch(input1);\n    return\n      string(\n        abi.encodePacked(\n          \"data:application/json;base64,\",\n          Base64.encode(\n            bytes(\n              string.concat(\n                '{\"name\":',\n                '\"',\n                _parseName(tokenId),\n                '\",',\n                '\"description\":',\n                '\"',\n                _parseDescription(tokenId),\n                '\",',\n                '\"image\":',\n                '\"',\n                image_,\n                '\",',\n                '\"attributes\": [',\n                traits_,\n                \"]\",\n                \"}\"\n              )\n            )\n          )\n        )\n      );\n  }\n\n  function constructContractURI() external view virtual returns (string memory uri) {\n    return\n      string(\n        abi.encodePacked(\n          \"data:application/json;base64,\",\n          Base64.encode(\n            bytes(\n              string.concat(\n                '{\"name\":',\n                '\"',\n                _contractURI.name,\n                '\",',\n                '\"description\":',\n                '\"',\n                _contractURI.description,\n                '\",',\n                '\"image\":',\n                '\"',\n                _contractURI.image,\n                '\",',\n                '\"externalLink\":',\n                '\"',\n                _contractURI.externalLink,\n                '\",',\n                '\"sellerFeeBasisPoints\":',\n                '\"',\n                _contractURI.sellerFeeBasisPoints,\n                '\",',\n                '\"feeRecipient\":',\n                '\"',\n                _contractURI.feeRecipient,\n                '\"',\n                \"}\"\n              )\n            )\n          )\n        )\n      );\n  }\n\n  function setSvgRender(address svgRender) external onlyOwner {\n    svgRenderInstance = svgRender;\n    emit SvgRenderUpdated(svgRender);\n  }\n\n  function setTraitsFetch(address traitsFetch) external onlyOwner {\n    traitsFetchInstance = traitsFetch;\n    emit TraitsFetchUpdated(traitsFetch);\n  }\n\n  function setContractURI(ContractURI memory contractURI) external onlyOwner {\n    _contractURI = contractURI;\n    emit ContractURIUpdated(contractURI);\n  }\n}\n"
    },
    "contracts/ERC721K/interfaces/IDataStream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IDataStream {\n  function get(address[] calldata targets, bytes[] calldata data)\n    external\n    view\n    returns (bytes memory value);\n}\n"
    },
    "contracts/ERC721K/interfaces/IERC721KImage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IERC721KImage {\n  function render(bytes memory input) external view returns (string memory);\n}\n"
    },
    "contracts/ERC721K/interfaces/IERC721KTraits.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IERC721KTraits {\n  enum DisplayType {\n    Base,\n    Generic,\n    BoostNumber,\n    BoostPercent,\n    Number,\n    Date\n  }\n\n  function fetch(bytes memory input) external view returns (string memory);\n}\n"
    },
    "contracts/ERC721K/interfaces/IStream.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IStream {\n  function count(address _address) external view returns (uint256);\n\n  function getData(address _address)\n    external\n    view\n    returns (string[] memory keys, string[] memory values);\n\n  function getValue(address _address, string memory _key) external view returns (string memory);\n}\n"
    },
    "contracts/ERC721K/interfaces/ISVGModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface ISVGModule {\n  function render(bytes memory input) external view returns (string memory);\n\n  function getEncoding() external view returns (string memory);\n}\n"
    },
    "contracts/ERC721K/interfaces/ISVGRender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface ISVGRender {\n  function render(bytes memory input) external view returns (string memory);\n}\n"
    },
    "contracts/ERC721K/interfaces/ITraitsFetch.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface ITraitsFetch {\n  function fetch(bytes memory input) external view returns (string memory);\n}\n"
    },
    "contracts/ERC721K/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author GonÃ§alo SÃ¡ <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes)\n        internal\n    {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\n                2\n            )\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (address)\n    {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint8)\n    {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint16)\n    {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint64)\n    {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint96)\n    {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint128)\n    {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes)\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\n                2\n            )\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/ERC721K/libraries/ECRecovery.sol": {
      "content": "pragma solidity 0.8.15;\n\n// SPDX-License-Identifier: MIT\n\ncontract ECRecovery {\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        //Check the signature length\n        if (sig.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n}\n"
    },
    "contracts/ERC721K/libraries/Strings.sol": {
      "content": "/*\n * @title String & slice utility library for Solidity contracts.\n * @author Nick Johnson <arachnid@notdot.net>\n *\n * @dev Functionality in this library is largely implemented using an\n *      abstraction called a 'slice'. A slice represents a part of a string -\n *      anything from the entire string to a single character, or even no\n *      characters at all (a 0-length slice). Since a slice only has to specify\n *      an offset and a length, copying and manipulating slices is a lot less\n *      expensive than copying and manipulating the strings they reference.\n *\n *      To further reduce gas costs, most functions on slice that need to return\n *      a slice modify the original one instead of allocating a new one; for\n *      instance, `s.split(\".\")` will return the text up to the first '.',\n *      modifying s to only contain the remainder of the string after the '.'.\n *      In situations where you do not want to modify the original slice, you\n *      can make a copy first with `.copy()`, for example:\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\n *      Solidity has no memory management, it will result in allocating many\n *      short-lived slices that are later discarded.\n *\n *      Functions that return two slices come in two versions: a non-allocating\n *      version that takes the second slice as an argument, modifying it in\n *      place, and an allocating version that allocates and returns the second\n *      slice; see `nextRune` for example.\n *\n *      Functions that have to copy string data will return strings rather than\n *      slices; these can be cast back to slices for further processing if\n *      required.\n *\n *      For convenience, some functions are provided with non-modifying\n *      variants that create a new slice and return both; for instance,\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\n *      corresponding to the left and right parts of the string.\n */\n\npragma solidity ^0.8.0;\n\nlibrary Strings {\n  struct slice {\n    uint256 _len;\n    uint256 _ptr;\n  }\n\n  function memcpy(\n    uint256 dest,\n    uint256 src,\n    uint256 len\n  ) private pure {\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    uint256 mask = type(uint256).max;\n    if (len > 0) {\n      mask = 256**(32 - len) - 1;\n    }\n    assembly {\n      let srcpart := and(mload(src), not(mask))\n      let destpart := and(mload(dest), mask)\n      mstore(dest, or(destpart, srcpart))\n    }\n  }\n\n  /*\n   * @dev Returns a slice containing the entire string.\n   * @param self The string to make a slice from.\n   * @return A newly allocated slice containing the entire string.\n   */\n  function toSlice(string memory self) internal pure returns (slice memory) {\n    uint256 ptr;\n    assembly {\n      ptr := add(self, 0x20)\n    }\n    return slice(bytes(self).length, ptr);\n  }\n\n  /*\n   * @dev Returns the length of a null-terminated bytes32 string.\n   * @param self The value to find the length of.\n   * @return The length of the string, from 0 to 32.\n   */\n  function len(bytes32 self) internal pure returns (uint256) {\n    uint256 ret;\n    if (self == 0) return 0;\n    if (uint256(self) & type(uint128).max == 0) {\n      ret += 16;\n      self = bytes32(uint256(self) / 0x100000000000000000000000000000000);\n    }\n    if (uint256(self) & type(uint64).max == 0) {\n      ret += 8;\n      self = bytes32(uint256(self) / 0x10000000000000000);\n    }\n    if (uint256(self) & type(uint32).max == 0) {\n      ret += 4;\n      self = bytes32(uint256(self) / 0x100000000);\n    }\n    if (uint256(self) & type(uint16).max == 0) {\n      ret += 2;\n      self = bytes32(uint256(self) / 0x10000);\n    }\n    if (uint256(self) & type(uint8).max == 0) {\n      ret += 1;\n    }\n    return 32 - ret;\n  }\n\n  /*\n   * @dev Returns a slice containing the entire bytes32, interpreted as a\n   *      null-terminated utf-8 string.\n   * @param self The bytes32 value to convert to a slice.\n   * @return A new slice containing the value of the input argument up to the\n   *         first null.\n   */\n  function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n    // Allocate space for `self` in memory, copy it there, and point ret at it\n    assembly {\n      let ptr := mload(0x40)\n      mstore(0x40, add(ptr, 0x20))\n      mstore(ptr, self)\n      mstore(add(ret, 0x20), ptr)\n    }\n    ret._len = len(self);\n  }\n\n  /*\n   * @dev Returns a new slice containing the same data as the current slice.\n   * @param self The slice to copy.\n   * @return A new slice containing the same data as `self`.\n   */\n  function copy(slice memory self) internal pure returns (slice memory) {\n    return slice(self._len, self._ptr);\n  }\n\n  /*\n   * @dev Copies a slice to a new string.\n   * @param self The slice to copy.\n   * @return A newly allocated string containing the slice's text.\n   */\n  function toString(slice memory self) internal pure returns (string memory) {\n    string memory ret = new string(self._len);\n    uint256 retptr;\n    assembly {\n      retptr := add(ret, 32)\n    }\n\n    memcpy(retptr, self._ptr, self._len);\n    return ret;\n  }\n\n  /*\n   * @dev Returns the length in runes of the slice. Note that this operation\n   *      takes time proportional to the length of the slice; avoid using it\n   *      in loops, and call `slice.empty()` if you only need to know whether\n   *      the slice is empty or not.\n   * @param self The slice to operate on.\n   * @return The length of the slice in runes.\n   */\n  function len(slice memory self) internal pure returns (uint256 l) {\n    // Starting at ptr-31 means the LSB will be the byte we care about\n    uint256 ptr = self._ptr - 31;\n    uint256 end = ptr + self._len;\n    for (l = 0; ptr < end; l++) {\n      uint8 b;\n      assembly {\n        b := and(mload(ptr), 0xFF)\n      }\n      if (b < 0x80) {\n        ptr += 1;\n      } else if (b < 0xE0) {\n        ptr += 2;\n      } else if (b < 0xF0) {\n        ptr += 3;\n      } else if (b < 0xF8) {\n        ptr += 4;\n      } else if (b < 0xFC) {\n        ptr += 5;\n      } else {\n        ptr += 6;\n      }\n    }\n  }\n\n  /*\n   * @dev Returns true if the slice is empty (has a length of 0).\n   * @param self The slice to operate on.\n   * @return True if the slice is empty, False otherwise.\n   */\n  function empty(slice memory self) internal pure returns (bool) {\n    return self._len == 0;\n  }\n\n  /*\n   * @dev Returns a positive number if `other` comes lexicographically after\n   *      `self`, a negative number if it comes before, or zero if the\n   *      contents of the two slices are equal. Comparison is done per-rune,\n   *      on unicode codepoints.\n   * @param self The first slice to compare.\n   * @param other The second slice to compare.\n   * @return The result of the comparison.\n   */\n  function compare(slice memory self, slice memory other) internal pure returns (int256) {\n    uint256 shortest = self._len;\n    if (other._len < self._len) shortest = other._len;\n\n    uint256 selfptr = self._ptr;\n    uint256 otherptr = other._ptr;\n    for (uint256 idx = 0; idx < shortest; idx += 32) {\n      uint256 a;\n      uint256 b;\n      assembly {\n        a := mload(selfptr)\n        b := mload(otherptr)\n      }\n      if (a != b) {\n        // Mask out irrelevant bytes and check again\n        uint256 mask = type(uint256).max; // 0xffff...\n        if (shortest < 32) {\n          mask = ~(2**(8 * (32 - shortest + idx)) - 1);\n        }\n        unchecked {\n          uint256 diff = (a & mask) - (b & mask);\n          if (diff != 0) return int256(diff);\n        }\n      }\n      selfptr += 32;\n      otherptr += 32;\n    }\n    return int256(self._len) - int256(other._len);\n  }\n\n  /*\n   * @dev Returns true if the two slices contain the same text.\n   * @param self The first slice to compare.\n   * @param self The second slice to compare.\n   * @return True if the slices are equal, false otherwise.\n   */\n  function equals(slice memory self, slice memory other) internal pure returns (bool) {\n    return compare(self, other) == 0;\n  }\n\n  /*\n   * @dev Extracts the first rune in the slice into `rune`, advancing the\n   *      slice to point to the next rune and returning `self`.\n   * @param self The slice to operate on.\n   * @param rune The slice that will contain the first rune.\n   * @return `rune`.\n   */\n  function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n    rune._ptr = self._ptr;\n\n    if (self._len == 0) {\n      rune._len = 0;\n      return rune;\n    }\n\n    uint256 l;\n    uint256 b;\n    // Load the first byte of the rune into the LSBs of b\n    assembly {\n      b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)\n    }\n    if (b < 0x80) {\n      l = 1;\n    } else if (b < 0xE0) {\n      l = 2;\n    } else if (b < 0xF0) {\n      l = 3;\n    } else {\n      l = 4;\n    }\n\n    // Check for truncated codepoints\n    if (l > self._len) {\n      rune._len = self._len;\n      self._ptr += self._len;\n      self._len = 0;\n      return rune;\n    }\n\n    self._ptr += l;\n    self._len -= l;\n    rune._len = l;\n    return rune;\n  }\n\n  /*\n   * @dev Returns the first rune in the slice, advancing the slice to point\n   *      to the next rune.\n   * @param self The slice to operate on.\n   * @return A slice containing only the first rune from `self`.\n   */\n  function nextRune(slice memory self) internal pure returns (slice memory ret) {\n    nextRune(self, ret);\n  }\n\n  /*\n   * @dev Returns the number of the first codepoint in the slice.\n   * @param self The slice to operate on.\n   * @return The number of the first codepoint in the slice.\n   */\n  function ord(slice memory self) internal pure returns (uint256 ret) {\n    if (self._len == 0) {\n      return 0;\n    }\n\n    uint256 word;\n    uint256 length;\n    uint256 divisor = 2**248;\n\n    // Load the rune into the MSBs of b\n    assembly {\n      word := mload(mload(add(self, 32)))\n    }\n    uint256 b = word / divisor;\n    if (b < 0x80) {\n      ret = b;\n      length = 1;\n    } else if (b < 0xE0) {\n      ret = b & 0x1F;\n      length = 2;\n    } else if (b < 0xF0) {\n      ret = b & 0x0F;\n      length = 3;\n    } else {\n      ret = b & 0x07;\n      length = 4;\n    }\n\n    // Check for truncated codepoints\n    if (length > self._len) {\n      return 0;\n    }\n\n    for (uint256 i = 1; i < length; i++) {\n      divisor = divisor / 256;\n      b = (word / divisor) & 0xFF;\n      if (b & 0xC0 != 0x80) {\n        // Invalid UTF-8 sequence\n        return 0;\n      }\n      ret = (ret * 64) | (b & 0x3F);\n    }\n\n    return ret;\n  }\n\n  /*\n   * @dev Returns the keccak-256 hash of the slice.\n   * @param self The slice to hash.\n   * @return The hash of the slice.\n   */\n  function keccak(slice memory self) internal pure returns (bytes32 ret) {\n    assembly {\n      ret := keccak256(mload(add(self, 32)), mload(self))\n    }\n  }\n\n  /*\n   * @dev Returns true if `self` starts with `needle`.\n   * @param self The slice to operate on.\n   * @param needle The slice to search for.\n   * @return True if the slice starts with the provided text, false otherwise.\n   */\n  function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n    if (self._len < needle._len) {\n      return false;\n    }\n\n    if (self._ptr == needle._ptr) {\n      return true;\n    }\n\n    bool equal;\n    assembly {\n      let length := mload(needle)\n      let selfptr := mload(add(self, 0x20))\n      let needleptr := mload(add(needle, 0x20))\n      equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n    }\n    return equal;\n  }\n\n  /*\n   * @dev If `self` starts with `needle`, `needle` is removed from the\n   *      beginning of `self`. Otherwise, `self` is unmodified.\n   * @param self The slice to operate on.\n   * @param needle The slice to search for.\n   * @return `self`\n   */\n  function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n    if (self._len < needle._len) {\n      return self;\n    }\n\n    bool equal = true;\n    if (self._ptr != needle._ptr) {\n      assembly {\n        let length := mload(needle)\n        let selfptr := mload(add(self, 0x20))\n        let needleptr := mload(add(needle, 0x20))\n        equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n      }\n    }\n\n    if (equal) {\n      self._len -= needle._len;\n      self._ptr += needle._len;\n    }\n\n    return self;\n  }\n\n  /*\n   * @dev Returns true if the slice ends with `needle`.\n   * @param self The slice to operate on.\n   * @param needle The slice to search for.\n   * @return True if the slice starts with the provided text, false otherwise.\n   */\n  function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n    if (self._len < needle._len) {\n      return false;\n    }\n\n    uint256 selfptr = self._ptr + self._len - needle._len;\n\n    if (selfptr == needle._ptr) {\n      return true;\n    }\n\n    bool equal;\n    assembly {\n      let length := mload(needle)\n      let needleptr := mload(add(needle, 0x20))\n      equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n    }\n\n    return equal;\n  }\n\n  /*\n   * @dev If `self` ends with `needle`, `needle` is removed from the\n   *      end of `self`. Otherwise, `self` is unmodified.\n   * @param self The slice to operate on.\n   * @param needle The slice to search for.\n   * @return `self`\n   */\n  function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n    if (self._len < needle._len) {\n      return self;\n    }\n\n    uint256 selfptr = self._ptr + self._len - needle._len;\n    bool equal = true;\n    if (selfptr != needle._ptr) {\n      assembly {\n        let length := mload(needle)\n        let needleptr := mload(add(needle, 0x20))\n        equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n      }\n    }\n\n    if (equal) {\n      self._len -= needle._len;\n    }\n\n    return self;\n  }\n\n  // Returns the memory address of the first byte of the first occurrence of\n  // `needle` in `self`, or the first byte after `self` if not found.\n  function findPtr(\n    uint256 selflen,\n    uint256 selfptr,\n    uint256 needlelen,\n    uint256 needleptr\n  ) private pure returns (uint256) {\n    uint256 ptr = selfptr;\n    uint256 idx;\n\n    if (needlelen <= selflen) {\n      if (needlelen <= 32) {\n        bytes32 mask;\n        if (needlelen > 0) {\n          mask = bytes32(~(2**(8 * (32 - needlelen)) - 1));\n        }\n\n        bytes32 needledata;\n        assembly {\n          needledata := and(mload(needleptr), mask)\n        }\n\n        uint256 end = selfptr + selflen - needlelen;\n        bytes32 ptrdata;\n        assembly {\n          ptrdata := and(mload(ptr), mask)\n        }\n\n        while (ptrdata != needledata) {\n          if (ptr >= end) return selfptr + selflen;\n          ptr++;\n          assembly {\n            ptrdata := and(mload(ptr), mask)\n          }\n        }\n        return ptr;\n      } else {\n        // For long needles, use hashing\n        bytes32 hash;\n        assembly {\n          hash := keccak256(needleptr, needlelen)\n        }\n\n        for (idx = 0; idx <= selflen - needlelen; idx++) {\n          bytes32 testHash;\n          assembly {\n            testHash := keccak256(ptr, needlelen)\n          }\n          if (hash == testHash) return ptr;\n          ptr += 1;\n        }\n      }\n    }\n    return selfptr + selflen;\n  }\n\n  // Returns the memory address of the first byte after the last occurrence of\n  // `needle` in `self`, or the address of `self` if not found.\n  function rfindPtr(\n    uint256 selflen,\n    uint256 selfptr,\n    uint256 needlelen,\n    uint256 needleptr\n  ) private pure returns (uint256) {\n    uint256 ptr;\n\n    if (needlelen <= selflen) {\n      if (needlelen <= 32) {\n        bytes32 mask;\n        if (needlelen > 0) {\n          mask = bytes32(~(2**(8 * (32 - needlelen)) - 1));\n        }\n\n        bytes32 needledata;\n        assembly {\n          needledata := and(mload(needleptr), mask)\n        }\n\n        ptr = selfptr + selflen - needlelen;\n        bytes32 ptrdata;\n        assembly {\n          ptrdata := and(mload(ptr), mask)\n        }\n\n        while (ptrdata != needledata) {\n          if (ptr <= selfptr) return selfptr;\n          ptr--;\n          assembly {\n            ptrdata := and(mload(ptr), mask)\n          }\n        }\n        return ptr + needlelen;\n      } else {\n        // For long needles, use hashing\n        bytes32 hash;\n        assembly {\n          hash := keccak256(needleptr, needlelen)\n        }\n        ptr = selfptr + (selflen - needlelen);\n        while (ptr >= selfptr) {\n          bytes32 testHash;\n          assembly {\n            testHash := keccak256(ptr, needlelen)\n          }\n          if (hash == testHash) return ptr + needlelen;\n          ptr -= 1;\n        }\n      }\n    }\n    return selfptr;\n  }\n\n  /*\n   * @dev Modifies `self` to contain everything from the first occurrence of\n   *      `needle` to the end of the slice. `self` is set to the empty slice\n   *      if `needle` is not found.\n   * @param self The slice to search and modify.\n   * @param needle The text to search for.\n   * @return `self`.\n   */\n  function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n    self._len -= ptr - self._ptr;\n    self._ptr = ptr;\n    return self;\n  }\n\n  /*\n   * @dev Modifies `self` to contain the part of the string from the start of\n   *      `self` to the end of the first occurrence of `needle`. If `needle`\n   *      is not found, `self` is set to the empty slice.\n   * @param self The slice to search and modify.\n   * @param needle The text to search for.\n   * @return `self`.\n   */\n  function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n    uint256 ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n    self._len = ptr - self._ptr;\n    return self;\n  }\n\n  /*\n   * @dev Splits the slice, setting `self` to everything after the first\n   *      occurrence of `needle`, and `token` to everything before it. If\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\n   *      and `token` is set to the entirety of `self`.\n   * @param self The slice to split.\n   * @param needle The text to search for in `self`.\n   * @param token An output parameter to which the first token is written.\n   * @return `token`.\n   */\n  function split(\n    slice memory self,\n    slice memory needle,\n    slice memory token\n  ) internal pure returns (slice memory) {\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n    token._ptr = self._ptr;\n    token._len = ptr - self._ptr;\n    if (ptr == self._ptr + self._len) {\n      // Not found\n      self._len = 0;\n    } else {\n      self._len -= token._len + needle._len;\n      self._ptr = ptr + needle._len;\n    }\n    return token;\n  }\n\n  /*\n   * @dev Splits the slice, setting `self` to everything after the first\n   *      occurrence of `needle`, and returning everything before it. If\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\n   *      and the entirety of `self` is returned.\n   * @param self The slice to split.\n   * @param needle The text to search for in `self`.\n   * @return The part of `self` up to the first occurrence of `delim`.\n   */\n  function split(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (slice memory token)\n  {\n    split(self, needle, token);\n  }\n\n  /*\n   * @dev Splits the slice, setting `self` to everything before the last\n   *      occurrence of `needle`, and `token` to everything after it. If\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\n   *      and `token` is set to the entirety of `self`.\n   * @param self The slice to split.\n   * @param needle The text to search for in `self`.\n   * @param token An output parameter to which the first token is written.\n   * @return `token`.\n   */\n  function rsplit(\n    slice memory self,\n    slice memory needle,\n    slice memory token\n  ) internal pure returns (slice memory) {\n    uint256 ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n    token._ptr = ptr;\n    token._len = self._len - (ptr - self._ptr);\n    if (ptr == self._ptr) {\n      // Not found\n      self._len = 0;\n    } else {\n      self._len -= token._len + needle._len;\n    }\n    return token;\n  }\n\n  /*\n   * @dev Splits the slice, setting `self` to everything before the last\n   *      occurrence of `needle`, and returning everything after it. If\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\n   *      and the entirety of `self` is returned.\n   * @param self The slice to split.\n   * @param needle The text to search for in `self`.\n   * @return The part of `self` after the last occurrence of `delim`.\n   */\n  function rsplit(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (slice memory token)\n  {\n    rsplit(self, needle, token);\n  }\n\n  /*\n   * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n   * @param self The slice to search.\n   * @param needle The text to search for in `self`.\n   * @return The number of occurrences of `needle` found in `self`.\n   */\n  function count(slice memory self, slice memory needle) internal pure returns (uint256 cnt) {\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n    while (ptr <= self._ptr + self._len) {\n      cnt++;\n      ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n    }\n  }\n\n  /*\n   * @dev Returns True if `self` contains `needle`.\n   * @param self The slice to search.\n   * @param needle The text to search for in `self`.\n   * @return True if `needle` is found in `self`, false otherwise.\n   */\n  function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n    return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n  }\n\n  /*\n   * @dev Returns a newly allocated string containing the concatenation of\n   *      `self` and `other`.\n   * @param self The first slice to concatenate.\n   * @param other The second slice to concatenate.\n   * @return The concatenation of the two strings.\n   */\n  function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n    string memory ret = new string(self._len + other._len);\n    uint256 retptr;\n    assembly {\n      retptr := add(ret, 32)\n    }\n    memcpy(retptr, self._ptr, self._len);\n    memcpy(retptr + self._len, other._ptr, other._len);\n    return ret;\n  }\n\n  /*\n   * @dev Joins an array of slices, using `self` as a delimiter, returning a\n   *      newly allocated string.\n   * @param self The delimiter to use.\n   * @param parts A list of slices to join.\n   * @return A newly allocated string containing all the slices in `parts`,\n   *         joined with `self`.\n   */\n  function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n    if (parts.length == 0) return \"\";\n\n    uint256 length = self._len * (parts.length - 1);\n    for (uint256 i = 0; i < parts.length; i++) length += parts[i]._len;\n\n    string memory ret = new string(length);\n    uint256 retptr;\n    assembly {\n      retptr := add(ret, 32)\n    }\n\n    for (uint256 i = 0; i < parts.length; i++) {\n      memcpy(retptr, parts[i]._ptr, parts[i]._len);\n      retptr += parts[i]._len;\n      if (i < parts.length - 1) {\n        memcpy(retptr, self._ptr, self._len);\n        retptr += self._len;\n      }\n    }\n\n    return ret;\n  }\n}\n"
    },
    "contracts/ERC721K/svg/svg.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./svgUtils.sol\";\n\n/**\n * @title svg\n * @author Kames Geraghty\n * @notice SVG construction library using web-like API.\n * @dev Original code from w1nt3r-eth/hot-chain-svg (https://github.com/w1nt3r-eth/hot-chain-svg)\n */\nlibrary svg {\n  using Strings for uint256;\n  using Strings for uint8;\n\n  function g(string memory _props, string memory _children) internal pure returns (string memory) {\n    return el(\"g\", _props, _children);\n  }\n\n  function path(string memory _props, string memory _children)\n    internal\n    pure\n    returns (string memory)\n  {\n    return el(\"path\", _props, _children);\n  }\n\n  function text(string memory _props, string memory _children)\n    internal\n    pure\n    returns (string memory)\n  {\n    return el(\"text\", _props, _children);\n  }\n\n  function line(string memory _props, string memory _children)\n    internal\n    pure\n    returns (string memory)\n  {\n    return el(\"line\", _props, _children);\n  }\n\n  function circle(string memory _props, string memory _children)\n    internal\n    pure\n    returns (string memory)\n  {\n    return el(\"circle\", _props, _children);\n  }\n\n  function circle(string memory _props) internal pure returns (string memory) {\n    return el(\"circle\", _props);\n  }\n\n  function rect(string memory _props, string memory _children)\n    internal\n    pure\n    returns (string memory)\n  {\n    return el(\"rect\", _props, _children);\n  }\n\n  function rect(string memory _props) internal pure returns (string memory) {\n    return el(\"rect\", _props);\n  }\n\n  function stop(string memory _props) internal pure returns (string memory) {\n    return el(\"stop\", _props);\n  }\n\n  function filter(string memory _props, string memory _children)\n    internal\n    pure\n    returns (string memory)\n  {\n    return el(\"filter\", _props, _children);\n  }\n\n  function defs(string memory _children) internal pure returns (string memory) {\n    return el(\"defs\", \"\", _children);\n  }\n\n  function cdata(string memory _content) internal pure returns (string memory) {\n    return string.concat(\"<![CDATA[\", _content, \"]]>\");\n  }\n\n  /* GRADIENTS */\n  function radialGradient(string memory _props, string memory _children)\n    internal\n    pure\n    returns (string memory)\n  {\n    return el(\"radialGradient\", _props, _children);\n  }\n\n  function linearGradient(string memory _props, string memory _children)\n    internal\n    pure\n    returns (string memory)\n  {\n    return el(\"linearGradient\", _props, _children);\n  }\n\n  function gradientStop(\n    uint256 offset,\n    string memory stopColor,\n    string memory _props\n  ) internal pure returns (string memory) {\n    return\n      el(\n        \"stop\",\n        string.concat(\n          prop(\"stop-color\", stopColor),\n          \" \",\n          prop(\"offset\", string.concat(svgUtils.uint2str(offset), \"%\")),\n          \" \",\n          _props\n        )\n      );\n  }\n\n  function animateTransform(string memory _props) internal pure returns (string memory) {\n    return el(\"animateTransform\", _props);\n  }\n\n  function image(string memory _href, string memory _props) internal pure returns (string memory) {\n    return el(\"image\", string.concat(prop(\"href\", _href), \" \", _props));\n  }\n\n  /* COMMON */\n  // A generic element, can be used to construct any SVG (or HTML) element\n  function el(\n    string memory _tag,\n    string memory _props,\n    string memory _children\n  ) internal pure returns (string memory) {\n    return string.concat(\"<\", _tag, \" \", _props, \">\", _children, \"</\", _tag, \">\");\n  }\n\n  // A generic element, can be used to construct any SVG (or HTML) element without children\n  function el(string memory _tag, string memory _props) internal pure returns (string memory) {\n    return string.concat(\"<\", _tag, \" \", _props, \"/>\");\n  }\n\n  function start(string memory _tag, string memory _props) internal pure returns (string memory) {\n    return string.concat(\"<\", _tag, \" \", _props, \">\");\n  }\n\n  function start(string memory _tag) internal pure returns (string memory) {\n    return string.concat(\"<\", _tag, \">\");\n  }\n\n  function end(string memory _tag) internal pure returns (string memory) {\n    return string.concat(\"</\", _tag, \">\");\n  }\n\n  // an SVG attribute\n  function prop(string memory _key, string memory _val) internal pure returns (string memory) {\n    return string.concat(_key, \"=\", '\"', _val, '\" ');\n  }\n\n  function stringifyIntSet(\n    bytes memory _data,\n    uint256 _offset,\n    uint256 _len\n  ) public pure returns (bytes memory) {\n    bytes memory res;\n    require(_data.length >= _offset + _len, \"Out of range\");\n    for (uint256 i = _offset; i < _offset + _len; i++) {\n      res = abi.encodePacked(res, byte2uint8(_data, i).toString(), \" \");\n    }\n    return res;\n  }\n\n  function byte2uint8(bytes memory _data, uint256 _offset) public pure returns (uint8) {\n    require(_data.length > _offset, \"Out of range\");\n    return uint8(_data[_offset]);\n  }\n}\n"
    },
    "contracts/ERC721K/svg/SVGColor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract SVGColor {\n  using Strings for uint256;\n  using Strings for uint8;\n  using Strings for bytes;\n\n  mapping(string => bytes) public colors;\n\n  constructor() {\n    colors[\"Black\"] = hex\"000000\";\n    colors[\"White\"] = hex\"FFFFFF\";\n    colors[\"Dark1\"] = hex\"232323\";\n    colors[\"Dark2\"] = hex\"464646\";\n  }\n\n  function getColor(string memory _colorName) public view returns (bytes memory) {\n    require(colors[_colorName].length == 3, \"Unknown color\");\n    return abi.encodePacked(colors[_colorName], hex\"64\");\n  }\n\n  function getColor(string memory _colorName, uint8 _alpha) public view returns (bytes memory) {\n    require(colors[_colorName].length == 3, \"Unknown color\");\n    return abi.encodePacked(colors[_colorName], _alpha);\n  }\n\n  function getRgba(string memory _colorName) public view returns (string memory) {\n    return string(toRgba(getColor(_colorName), 0));\n  }\n\n  // Input: array of colors (without alpha)\n  // Ouputs a linearGradient\n  function autoLinearGradient(\n    bytes memory _colors,\n    bytes memory _id,\n    bytes memory _customAttributes\n  ) public view returns (bytes memory) {\n    return this.autoLinearGradient(\"\", _colors, _id, _customAttributes);\n  }\n\n  function autoLinearGradient(\n    bytes memory _coordinates,\n    bytes memory _colors,\n    bytes memory _id,\n    bytes memory _customAttributes\n  ) external view returns (bytes memory) {\n    bytes memory _b;\n    if (_coordinates.length > 3) {\n      _b = abi.encodePacked(uint8(128), _coordinates);\n    } else {\n      _b = hex\"00\";\n    }\n    // Count the number of colors passed, each on 4 byte\n    uint256 colorCount = _colors.length / 4;\n    uint8 i = 0;\n    while (i < colorCount) {\n      _b = abi.encodePacked(\n        _b,\n        uint8(i * (100 / (colorCount - 1))), // grad. stop %\n        uint8(_colors[i * 4]),\n        uint8(_colors[i * 4 + 1]),\n        uint8(_colors[i * 4 + 2]),\n        uint8(_colors[i * 4 + 3])\n      );\n      i++;\n    }\n    return linearGradient(_b, _id, _customAttributes);\n  }\n\n  function linearGradient(\n    bytes memory _lg,\n    bytes memory _id,\n    bytes memory _customAttributes\n  ) public pure returns (bytes memory) {\n    bytes memory grdata;\n    uint8 offset = 1;\n\n    if (uint8(_lg[0]) & 128 == 128) {\n      grdata = abi.encodePacked(\n        'x1=\"',\n        byte2uint8(_lg, 1).toString(),\n        '%\" x2=\"',\n        byte2uint8(_lg, 2).toString(),\n        '%\" y1=\"',\n        byte2uint8(_lg, 3).toString(),\n        '%\" y2=\"',\n        byte2uint8(_lg, 4).toString(),\n        '%\"'\n      );\n      offset = 5;\n    }\n    grdata = abi.encodePacked('<linearGradient id=\"', _id, '\" ', _customAttributes, grdata, \">\");\n    for (uint256 i = offset; i < _lg.length; i += 5) {\n      grdata = abi.encodePacked(\n        grdata,\n        '<stop offset=\"',\n        byte2uint8(_lg, i).toString(),\n        '%\" stop-color=\"',\n        toRgba(_lg, i + 1),\n        '\" id=\"',\n        _id,\n        byte2uint8(_lg, i).toString(),\n        '\"/>'\n      );\n    }\n    return abi.encodePacked(grdata, \"</linearGradient>\");\n  }\n\n  function toRgba(bytes memory _rgba, uint256 offset) public pure returns (bytes memory) {\n    return\n      abi.encodePacked(\n        \"rgba(\",\n        byte2uint8(_rgba, offset).toString(),\n        \",\",\n        byte2uint8(_rgba, offset + 1).toString(),\n        \",\",\n        byte2uint8(_rgba, offset + 2).toString(),\n        \",\",\n        byte2uint8(_rgba, offset + 3).toString(),\n        \"%)\"\n      );\n  }\n\n  function byte2uint8(bytes memory _data, uint256 _offset) public pure returns (uint8) {\n    require(_data.length > _offset, \"Out of range\");\n    return uint8(_data[_offset]);\n  }\n\n  // formats rgba white with a specified opacity / alpha\n  function white_a(uint256 _a) internal pure returns (string memory) {\n    return rgba(255, 255, 255, _a);\n  }\n\n  // formats rgba black with a specified opacity / alpha\n  function black_a(uint256 _a) internal pure returns (string memory) {\n    return rgba(0, 0, 0, _a);\n  }\n\n  // formats generic rgba color in css\n  function rgba(\n    uint256 _r,\n    uint256 _g,\n    uint256 _b,\n    uint256 _a\n  ) internal pure returns (string memory) {\n    string memory formattedA = _a < 100 ? string.concat(\"0.\", uint2str(_a)) : \"1\";\n    return\n      string.concat(\n        \"rgba(\",\n        uint2str(_r),\n        \",\",\n        uint2str(_g),\n        \",\",\n        uint2str(_b),\n        \",\",\n        formattedA,\n        \")\"\n      );\n  }\n\n  function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n    uint256 j = _i;\n    uint256 len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint256 k = len;\n    while (_i != 0) {\n      k = k - 1;\n      uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n      bytes1 b1 = bytes1(temp);\n      bstr[k] = b1;\n      _i /= 10;\n    }\n    return string(bstr);\n  }\n}\n"
    },
    "contracts/ERC721K/svg/SVGLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { svg } from \"./svg.sol\";\nimport { svgUtils } from \"./svgUtils.sol\";\nimport { SVGColor } from \"./SVGColor.sol\";\n\ncontract SVGLibrary {\n  address private _colors;\n\n  bytes32 private immutable BUILD = keccak256(\"BUILD\");\n  bytes32 private immutable COLOR = keccak256(\"COLOR\");\n  bytes32 private immutable UTILS = keccak256(\"UTILS\");\n\n  mapping(bytes32 => address) _modules;\n\n  constructor(address _colors_) {\n    _colors = _colors_;\n  }\n\n  function execute(bytes32 package, bytes calldata input)\n    external\n    view\n    returns (string memory data)\n  {\n    if (_modules[package] != 0x0000000000000000000000000000000000000000) {\n      (bool success, bytes memory data) = address(_modules[package]).staticcall(input);\n      return string(data);\n    } else if (package == BUILD) {\n      (bool success, bytes memory data) = address(svg).staticcall(input);\n      return string(data);\n    } else if (package == COLOR) {\n      (bool success, bytes memory data) = _colors.staticcall(input);\n      return string(data);\n    } else if (package == UTILS) {\n      (bool success, bytes memory data) = address(svgUtils).staticcall(input);\n      return string(data);\n    } else {\n      return string(data);\n      revert(\"SVGLibrary:invalid-operation\");\n    }\n  }\n}\n"
    },
    "contracts/ERC721K/svg/SVGRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Owned } from \"../../Solbase/Owned.sol\";\nimport { ISVGModule } from \"../interfaces/ISVGModule.sol\";\n\ncontract SVGRegistry is Owned {\n  mapping(bytes32 => address) private _modules;\n\n  constructor() Owned(msg.sender) {}\n\n  function fetch(bytes32 widgetId, bytes memory input) external view returns (string memory) {\n    if (_modules[widgetId] != address(0)) {\n      return \"ISVGModule(_modules[widgetId]).decode(input);\";\n    } else {\n      return \"\";\n    }\n  }\n\n  function getWidget(bytes32 widgetId) external view returns (address widget) {\n    return _modules[widgetId];\n  }\n\n  function setWidget(bytes32 widgetId, address widget) external onlyOwner {\n    _modules[widgetId] = widget;\n  }\n}\n"
    },
    "contracts/ERC721K/svg/svgUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { BytesLib } from \"../libraries/BytesLib.sol\";\n\n/**\n * @title  SVG Utilities\n * @author Kames Geraghty\n * @notice The SVG Utilities Library provides functions for constructing SVG; format CSS and numbers.\n * @dev Original code from w1nt3r-eth/hot-chain-svg (https://github.com/w1nt3r-eth/hot-chain-svg)\n */\nlibrary svgUtils {\n  using Strings for uint256;\n  using Strings for uint8;\n\n  /// @notice Empty SVG element\n  string internal constant NULL = \"\";\n\n  /**\n   * @notice Formats a CSS variable line. Includes a semicolon for formatting.\n   * @param _key User for which to calculate prize amount.\n   * @param _val User for which to calculate prize amount.\n   * @return string Generated CSS variable.\n   */\n  function setCssVar(string memory _key, string memory _val) internal pure returns (string memory) {\n    return string.concat(\"--\", _key, \":\", _val, \";\");\n  }\n\n  /**\n   * @notice Formats getting a css variable\n   * @param _key User for which to calculate prize amount.\n   * @return string Generated CSS variable.\n   */\n  function getCssVar(string memory _key) internal pure returns (string memory) {\n    return string.concat(\"var(--\", _key, \")\");\n  }\n\n  // formats getting a def URL\n  function getDefURL(string memory _id) internal pure returns (string memory) {\n    return string.concat(\"url(#\", _id, \")\");\n  }\n\n  // checks if two Strings are equal\n  function StringsEqual(string memory _a, string memory _b) internal pure returns (bool) {\n    return keccak256(abi.encodePacked(_a)) == keccak256(abi.encodePacked(_b));\n  }\n\n  // returns the length of a string in characters\n  function utfStringLength(string memory _str) internal pure returns (uint256 length) {\n    uint256 i = 0;\n    bytes memory string_rep = bytes(_str);\n\n    while (i < string_rep.length) {\n      if (string_rep[i] >> 7 == 0) i += 1;\n      else if (string_rep[i] >> 5 == bytes1(uint8(0x6))) i += 2;\n      else if (string_rep[i] >> 4 == bytes1(uint8(0xE))) i += 3;\n      else if (string_rep[i] >> 3 == bytes1(uint8(0x1E)))\n        i += 4;\n        //For safety\n      else i += 1;\n\n      length++;\n    }\n  }\n\n  function round2Txt(\n    uint256 _value,\n    uint8 _decimals,\n    uint8 _prec\n  ) internal pure returns (bytes memory) {\n    return\n      abi.encodePacked(\n        (_value / 10**_decimals).toString(),\n        \".\",\n        (_value / 10**(_decimals - _prec) - (_value / 10**(_decimals)) * 10**_prec).toString()\n      );\n  }\n\n  // converts an unsigned integer to a string\n  function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n    uint256 j = _i;\n    uint256 len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint256 k = len;\n    while (_i != 0) {\n      k = k - 1;\n      uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n      bytes1 b1 = bytes1(temp);\n      bstr[k] = b1;\n      _i /= 10;\n    }\n    return string(bstr);\n  }\n\n  function splitAddress(address account) internal pure returns (string memory) {\n    string memory addy = Strings.toHexString(uint256(uint160(account)), 20);\n    bytes memory start = BytesLib.slice(abi.encodePacked(addy), 0, 6);\n    bytes memory end = BytesLib.slice(abi.encodePacked(addy), 37, 4);\n    return string.concat(string(abi.encodePacked(start)), \"...\", string(abi.encodePacked(end)));\n  }\n\n  function toString(address account) internal pure returns (string memory) {\n    return toString(abi.encodePacked(account));\n  }\n\n  function toString(uint256 value) internal pure returns (string memory) {\n    return toString(abi.encodePacked(value));\n  }\n\n  function toString(bytes32 value) internal pure returns (string memory) {\n    return toString(abi.encodePacked(value));\n  }\n\n  function toString(bytes memory data) internal pure returns (string memory) {\n    bytes memory alphabet = \"0123456789abcdef\";\n\n    bytes memory str = new bytes(2 + data.length * 2);\n    str[0] = \"0\";\n    str[1] = \"x\";\n    for (uint256 i = 0; i < data.length; i++) {\n      str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n      str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n    }\n    return string(str);\n  }\n\n  function getColor(bytes memory _colorHex) internal view returns (bytes memory) {\n    require(_colorHex.length == 3, \"Unknown color\");\n    return abi.encodePacked(_colorHex, hex\"64\");\n  }\n\n  function getColor(bytes memory _colorHex, uint8 _alpha) internal view returns (bytes memory) {\n    require(_colorHex.length == 3, \"Unknown color\");\n    return abi.encodePacked(_colorHex, _alpha);\n  }\n\n  function getRgba(bytes memory _colorHex) internal view returns (string memory) {\n    return string(toRgba(getColor(_colorHex), 0));\n  }\n\n  function toRgba(bytes memory _rgba, uint256 offset) internal pure returns (bytes memory) {\n    return\n      abi.encodePacked(\n        \"rgba(\",\n        byte2uint8(_rgba, offset).toString(),\n        \",\",\n        byte2uint8(_rgba, offset + 1).toString(),\n        \",\",\n        byte2uint8(_rgba, offset + 2).toString(),\n        \",\",\n        byte2uint8(_rgba, offset + 3).toString(),\n        \"%)\"\n      );\n  }\n\n  function byte2uint8(bytes memory _data, uint256 _offset) internal pure returns (uint8) {\n    require(_data.length > _offset, \"Out of range\");\n    return uint8(_data[_offset]);\n  }\n}\n"
    },
    "contracts/PoolTogether/ERC20TWAB.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"../Solbase/ERC20.sol\";\nimport { ERC20Permit } from \"../Solbase/ERC20Permit.sol\";\nimport { ObservationLib } from \"./twab/ObservationLib.sol\";\nimport { TwabLib } from \"./twab/TwabLib.sol\";\nimport { ExtendedSafeCastLib } from \"./twab/ExtendedSafeCastLib.sol\";\n\n/**\n * @title ERC20TWAB\n * @author Kames Geraghty\n * @notice ERC20TWAB is an experiment. Implementing time-weighted average balances on more ERC20 tokens.\n           Credit: PoolTogether Inc (Brendan Asselstine)\n */\ncontract ERC20TWAB is ERC20 {\n  // using SafeERC20 for IERC20;\n  using ExtendedSafeCastLib for uint256;\n\n  uint256 private distribution = 10000e18;\n\n  bytes32 private immutable _DELEGATE_TYPEHASH =\n    keccak256(\"Delegate(address user,address delegate,uint256 nonce,uint256 deadline)\");\n\n  /// @notice Record of token holders TWABs for each account.\n  mapping(address => TwabLib.Account) internal userTwabs;\n\n  /// @notice Record of tickets total supply and ring buff parameters used for observation.\n  TwabLib.Account internal totalSupplyTwab;\n\n  /// @notice Mapping of delegates.  Each address can delegate their ticket power to another.\n  mapping(address => address) internal delegates;\n\n  /**\n   * @notice Emitted when TWAB balance has been delegated to another user.\n   * @param delegator Address of the delegator.\n   * @param delegate Address of the delegate.\n   */\n  event Delegated(address indexed delegator, address indexed delegate);\n\n  /**\n   * @notice Emitted when a new TWAB has been recorded.\n   * @param delegate The recipient of the ticket power (may be the same as the user).\n   * @param newTwab Updated TWAB of a ticket holder after a successful TWAB recording.\n   */\n  event NewUserTwab(address indexed delegate, ObservationLib.Observation newTwab);\n\n  /**\n   * @notice Emitted when a new total supply TWAB has been recorded.\n   * @param newTotalSupplyTwab Updated TWAB of tickets total supply after a successful total supply TWAB recording.\n   */\n  event NewTotalSupplyTwab(ObservationLib.Observation newTotalSupplyTwab);\n\n  constructor(string memory name, string memory symbol)\n    ERC20(name, symbol, 18)\n  {}\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n\n  function getAccountDetails(address _user) external view returns (TwabLib.AccountDetails memory) {\n    return userTwabs[_user].details;\n  }\n\n  function getTwab(address _user, uint16 _index)\n    external\n    view\n    returns (ObservationLib.Observation memory)\n  {\n    return userTwabs[_user].twabs[_index];\n  }\n\n  function getBalanceAt(address _user, uint64 _target) external view returns (uint256) {\n    TwabLib.Account storage account = userTwabs[_user];\n\n    return\n      TwabLib.getBalanceAt(\n        account.twabs,\n        account.details,\n        uint32(_target),\n        uint32(block.timestamp)\n      );\n  }\n\n  function getAverageBalancesBetween(\n    address _user,\n    uint64[] calldata _startTimes,\n    uint64[] calldata _endTimes\n  ) external view returns (uint256[] memory) {\n    return _getAverageBalancesBetween(userTwabs[_user], _startTimes, _endTimes);\n  }\n\n  function getAverageTotalSuppliesBetween(\n    uint64[] calldata _startTimes,\n    uint64[] calldata _endTimes\n  ) external view returns (uint256[] memory) {\n    return _getAverageBalancesBetween(totalSupplyTwab, _startTimes, _endTimes);\n  }\n\n  function getAverageBalanceBetween(\n    address _user,\n    uint64 _startTime,\n    uint64 _endTime\n  ) external view returns (uint256) {\n    TwabLib.Account storage account = userTwabs[_user];\n\n    return\n      TwabLib.getAverageBalanceBetween(\n        account.twabs,\n        account.details,\n        uint32(_startTime),\n        uint32(_endTime),\n        uint32(block.timestamp)\n      );\n  }\n\n  function getBalancesAt(address _user, uint64[] calldata _targets)\n    external\n    view\n    returns (uint256[] memory)\n  {\n    uint256 length = _targets.length;\n    uint256[] memory _balances = new uint256[](length);\n\n    TwabLib.Account storage twabContext = userTwabs[_user];\n    TwabLib.AccountDetails memory details = twabContext.details;\n\n    for (uint256 i = 0; i < length; i++) {\n      _balances[i] = TwabLib.getBalanceAt(\n        twabContext.twabs,\n        details,\n        uint32(_targets[i]),\n        uint32(block.timestamp)\n      );\n    }\n\n    return _balances;\n  }\n\n  function getTotalSupplyAt(uint64 _target) external view returns (uint256) {\n    return\n      TwabLib.getBalanceAt(\n        totalSupplyTwab.twabs,\n        totalSupplyTwab.details,\n        uint32(_target),\n        uint32(block.timestamp)\n      );\n  }\n\n  function getTotalSuppliesAt(uint64[] calldata _targets) external view returns (uint256[] memory) {\n    uint256 length = _targets.length;\n    uint256[] memory totalSupplies = new uint256[](length);\n\n    TwabLib.AccountDetails memory details = totalSupplyTwab.details;\n\n    for (uint256 i = 0; i < length; i++) {\n      totalSupplies[i] = TwabLib.getBalanceAt(\n        totalSupplyTwab.twabs,\n        details,\n        uint32(_targets[i]),\n        uint32(block.timestamp)\n      );\n    }\n\n    return totalSupplies;\n  }\n\n  function delegateOf(address _user) external view returns (address) {\n    return delegates[_user];\n  }\n\n\n  function delegate(address _to) external virtual {\n    _delegate(msg.sender, _to);\n  }\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n\n  /// @notice Delegates a users chance to another\n  /// @param _user The user whose balance should be delegated\n  /// @param _to The delegate\n  function _delegate(address _user, address _to) internal {\n    uint256 balance = 0;\n    address currentDelegate = delegates[_user];\n\n    if (currentDelegate == _to) {\n      return;\n    }\n\n    delegates[_user] = _to;\n\n    _transferTwab(currentDelegate, _to, balance);\n\n    emit Delegated(_user, _to);\n  }\n\n  /**\n   * @notice Retrieves the average balances held by a user for a given time frame.\n   * @param _account The user whose balance is checked.\n   * @param _startTimes The start time of the time frame.\n   * @param _endTimes The end time of the time frame.\n   * @return The average balance that the user held during the time frame.\n   */\n  function _getAverageBalancesBetween(\n    TwabLib.Account storage _account,\n    uint64[] calldata _startTimes,\n    uint64[] calldata _endTimes\n  ) internal view returns (uint256[] memory) {\n    uint256 startTimesLength = _startTimes.length;\n    require(startTimesLength == _endTimes.length, \"Ticket/start-end-times-length-match\");\n\n    TwabLib.AccountDetails memory accountDetails = _account.details;\n\n    uint256[] memory averageBalances = new uint256[](startTimesLength);\n    uint32 currentTimestamp = uint32(block.timestamp);\n\n    for (uint256 i = 0; i < startTimesLength; i++) {\n      averageBalances[i] = TwabLib.getAverageBalanceBetween(\n        _account.twabs,\n        accountDetails,\n        uint32(_startTimes[i]),\n        uint32(_endTimes[i]),\n        currentTimestamp\n      );\n    }\n\n    return averageBalances;\n  }\n\n  /// @notice Transfers the given TWAB balance from one user to another\n  /// @param _from The user to transfer the balance from.  May be zero in the event of a mint.\n  /// @param _to The user to transfer the balance to.  May be zero in the event of a burn.\n  /// @param _amount The balance that is being transferred.\n  function _transferTwab(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal {\n    // If we are transferring tokens from a delegated account to an undelegated account\n    if (_from != address(0)) {\n      _decreaseUserTwab(_from, _amount);\n\n      if (_to == address(0)) {\n        _decreaseTotalSupplyTwab(_amount);\n      }\n    }\n\n    // If we are transferring tokens from an undelegated account to a delegated account\n    if (_to != address(0)) {\n      _increaseUserTwab(_to, _amount);\n\n      if (_from == address(0)) {\n        _increaseTotalSupplyTwab(_amount);\n      }\n    }\n  }\n\n  /**\n   * @notice Increase `_to` TWAB balance.\n   * @param _to Address of the delegate.\n   * @param _amount Amount of tokens to be added to `_to` TWAB balance.\n   */\n  function _increaseUserTwab(address _to, uint256 _amount) internal {\n    if (_amount == 0) {\n      return;\n    }\n\n    TwabLib.Account storage _account = userTwabs[_to];\n\n    (\n      TwabLib.AccountDetails memory accountDetails,\n      ObservationLib.Observation memory twab,\n      bool isNew\n    ) = TwabLib.increaseBalance(_account, _amount.toUint208(), uint32(block.timestamp));\n\n    _account.details = accountDetails;\n\n    if (isNew) {\n      emit NewUserTwab(_to, twab);\n    }\n  }\n\n  /**\n   * @notice Decrease `_to` TWAB balance.\n   * @param _to Address of the delegate.\n   * @param _amount Amount of tokens to be added to `_to` TWAB balance.\n   */\n  function _decreaseUserTwab(address _to, uint256 _amount) internal {\n    if (_amount == 0) {\n      return;\n    }\n\n    TwabLib.Account storage _account = userTwabs[_to];\n\n    (\n      TwabLib.AccountDetails memory accountDetails,\n      ObservationLib.Observation memory twab,\n      bool isNew\n    ) = TwabLib.decreaseBalance(\n        _account,\n        _amount.toUint208(),\n        \"Ticket/twab-burn-lt-balance\",\n        uint32(block.timestamp)\n      );\n\n    _account.details = accountDetails;\n\n    if (isNew) {\n      emit NewUserTwab(_to, twab);\n    }\n  }\n\n  /// @notice Decreases the total supply twab.  Should be called anytime a balance moves from delegated to undelegated\n  /// @param _amount The amount to decrease the total by\n  function _decreaseTotalSupplyTwab(uint256 _amount) internal {\n    if (_amount == 0) {\n      return;\n    }\n\n    (\n      TwabLib.AccountDetails memory accountDetails,\n      ObservationLib.Observation memory tsTwab,\n      bool tsIsNew\n    ) = TwabLib.decreaseBalance(\n        totalSupplyTwab,\n        _amount.toUint208(),\n        \"Ticket/burn-amount-exceeds-total-supply-twab\",\n        uint32(block.timestamp)\n      );\n\n    totalSupplyTwab.details = accountDetails;\n\n    if (tsIsNew) {\n      emit NewTotalSupplyTwab(tsTwab);\n    }\n  }\n\n  /// @notice Increases the total supply twab.  Should be called anytime a balance moves from undelegated to delegated\n  /// @param _amount The amount to increase the total by\n  function _increaseTotalSupplyTwab(uint256 _amount) internal {\n    if (_amount == 0) {\n      return;\n    }\n\n    (\n      TwabLib.AccountDetails memory accountDetails,\n      ObservationLib.Observation memory _totalSupply,\n      bool tsIsNew\n    ) = TwabLib.increaseBalance(totalSupplyTwab, _amount.toUint208(), uint32(block.timestamp));\n\n    totalSupplyTwab.details = accountDetails;\n\n    if (tsIsNew) {\n      emit NewTotalSupplyTwab(_totalSupply);\n    }\n  }\n\n  // @inheritdoc ERC20\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal  {\n    if (_from == _to) {\n      return;\n    }\n\n    address _fromDelegate;\n    if (_from != address(0)) {\n      _fromDelegate = delegates[_from];\n    }\n\n    address _toDelegate;\n    if (_to != address(0)) {\n      _toDelegate = delegates[_to];\n    }\n\n    _transferTwab(_fromDelegate, _toDelegate, _amount);\n  }\n}\n"
    },
    "contracts/PoolTogether/PoolTogetherV0Render.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n\nimport { Base64 } from \"../Solbase/Base64.sol\";\nimport { Owned } from \"../Solbase/Owned.sol\";\nimport { SVGLibrary } from \"../ERC721K/svg/SVGLibrary.sol\";\nimport { SVGRegistry } from \"../ERC721K/svg/SVGRegistry.sol\";\n\nimport { svg } from \"../ERC721K/svg/svg.sol\";\nimport { svgUtils } from \"../ERC721K/svg/svgUtils.sol\";\n\ncontract PoolTogetherV0Render is Owned {\n  bytes32 private constant BYTES32_WEB3_ASSETS =\n    0x574542335f415353455453000000000000000000000000000000000000000000;\n  bytes32 private constant BYTES32_TOKEN_USDC =\n    0x544f4b454e5f5553444300000000000000000000000000000000000000000000;\n  bytes32 private constant BYTES32_TOKEN_POOL =\n    0x544f4b454e5f504f4f4c00000000000000000000000000000000000000000000;\n  bytes32 private constant BYTES32_LOGO_POOL =\n    0x4c4f474f5f504f4f4c0000000000000000000000000000000000000000000000;\n  bytes32 private constant BYTES32_ICON_NETWORK_TEST =\n    0x49434f4e5f4e4554574f524b5f54455354000000000000000000000000000000;\n  bytes32 private constant BYTES32_ICON_NETWORK_ETHEREUM =\n    0x49434f4e5f4e4554574f524b5f455448455245554d0000000000000000000000;\n  bytes32 private constant BYTES32_ICON_NETWORK_OPTIMISM =\n    0x49434f4e5f4e4554574f524b5f4f5054494d49534d0000000000000000000000;\n  bytes32 private constant BYTES32_ICON_NETWORK_ARBITRUM =\n    0x49434f4e5f4e4554574f524b5f415242495452554d0000000000000000000000;\n  bytes32 private constant BYTES32_ICON_NETWORK_POLYGON =\n    0x49434f4e5f4e4554574f524b5f504f4c59474f4e000000000000000000000000;\n  string private constant ENCODING = \"data:image/svg+xml;base64, \";\n\n  address public svgLibrary;\n  address public svgRegistry;\n\n  constructor(address svgLibrary_, address svgRegistry_) Owned(msg.sender)  {\n    svgLibrary = svgLibrary_;\n    svgRegistry = svgRegistry_;\n  }\n\n  /* ===================================================================================== */\n  /* External Functions                                                                    */\n  /* ===================================================================================== */\n\n  function render(bytes memory input) external view returns (string memory) {\n    return string(abi.encodePacked(ENCODING, Base64.encode(bytes(_construct(input)))));\n  }\n\n  /* ===================================================================================== */\n  /* Internal Functions                                                                    */\n  /* ===================================================================================== */\n  function _construct(bytes memory input) internal view returns (string memory) {\n    (\n      address account,\n      address asset,\n      uint256 balance,\n      uint256 chance,\n      uint256 avgBalance2Weeks,\n      uint256 avgBalance8Weeks,\n      uint256 avgBalance26Weeks,\n      uint256 avgBalance52Weeks,\n      string memory emoji,\n      bytes memory color\n    ) = abi.decode(\n        input,\n        (address, address, uint256, uint256, uint256, uint256, uint256, uint256, string, bytes)\n      );\n\n    string memory tagline = \"Web3 Savings Network\";\n\n    return\n      string.concat(\n        svg.start(\n          \"svg\",\n          string.concat(\n            svg.prop(\"xmlns\", \"http://www.w3.org/2000/svg\"),\n            svg.prop(\"font-family\", \"Roboto, sans-serif\"),\n            svg.prop(\"height\", \"300\"),\n            svg.prop(\"width\", \"500\"),\n            svg.prop(\"viewbox\", \"0 0 500 300\"),\n            svg.prop(\"style\", \"border-radius: 10px;\"),\n            svg.prop(\"fill\", string(svgUtils.getRgba(color)))\n          )\n        ),\n        renderDesign(color),\n        renderHeader(chance),\n        renderFooter(account, avgBalance8Weeks, emoji, tagline),\n        \"<defs><style>.text-shadow-md {text-shadow: 0px 4px 10px rgba(0, 0, 0, 0.12);}</style></defs>\",\n        svg.end(\"svg\")\n      );\n  }\n\n  function renderDesign(bytes memory color) internal view returns (string memory) {\n    return\n      string.concat(\n        // svg.rect(\n        //   string.concat(\n        //     svg.prop(\"x\", \"0.00195312\"),\n        //     svg.prop(\"width\", \"500\"),\n        //     svg.prop(\"height\", \"300\"),\n        //     // svg.prop(\"fill\", string(svgUtils.getRgba(color)))\n        //   )\n        // ),\n        svg.rect(\n          string.concat(svg.prop(\"x\", \"0\"), svg.prop(\"width\", \"500\"), svg.prop(\"height\", \"500\"))\n        ),\n        svg.g(\n          \"\",\n          string.concat(\n            '<ellipse opacity=\"0.1\" cx=\"93\" cy=\"300\" rx=\"230\" ry=\"145\" fill=\"black\"/>',\n            '<ellipse opacity=\"0.08\" cx=\"550\" cy=\"-119\" rx=\"450\" ry=\"247\" fill=\"black\"/>'\n          )\n        )\n      );\n  }\n\n  function renderHeader(uint256 balance) internal view returns (string memory) {\n    return string.concat(chanceDetails(balance), cardDetails());\n  }\n\n  function cardDetails() internal view returns (string memory) {\n    return\n      string.concat(\n        svg.g(\n          string.concat(svg.prop(\"transform\", \"translate(350,30)\")),\n          _registry(BYTES32_WEB3_ASSETS, abi.encode(BYTES32_LOGO_POOL))\n        )\n      );\n  }\n\n  function chanceDetails(uint256 balance) internal view returns (string memory) {\n    return\n      string.concat(\n        svg.text(\n          string.concat(\n            svg.prop(\"x\", \"7.5%\"),\n            svg.prop(\"y\", \"62.5\"),\n            svg.prop(\"font-size\", \"18\"),\n            svg.prop(\"alignment-baseline\", \"middle\"),\n            svg.prop(\"text-anchor\", \"start\"),\n            svg.prop(\"fill\", \"white\")\n          ),\n          string.concat(unicode\"ðŸ†\", \" Total Chance\")\n        ),\n        svg.text(\n          string.concat(\n            svg.prop(\"x\", \"7.5%\"),\n            svg.prop(\"y\", \"100\"),\n            svg.prop(\"font-size\", \"32\"),\n            svg.prop(\"alignment-baseline\", \"middle\"),\n            svg.prop(\"text-anchor\", \"start\"),\n            svg.prop(\"fill\", \"white\")\n          ),\n          string.concat(\"$\", string(svgUtils.round2Txt(balance, 6, 2)))\n        )\n      );\n  }\n\n  function avgBalanceDetails(uint256 avgBalance8Weeks) internal view returns (string memory) {\n    return\n      string.concat(\n        svg.text(\n          string.concat(\n            svg.prop(\"x\", \"95%\"),\n            svg.prop(\"y\", \"50%\"),\n            svg.prop(\"font-size\", \"14\"),\n            svg.prop(\"alignment-baseline\", \"middle\"),\n            svg.prop(\"text-anchor\", \"end\"),\n            svg.prop(\"fill\", \"white\")\n          ),\n          \"60 Day Avg.\"\n        ),\n        svg.text(\n          string.concat(\n            svg.prop(\"x\", \"95%\"),\n            svg.prop(\"y\", \"60%\"),\n            svg.prop(\"font-size\", \"24\"),\n            svg.prop(\"alignment-baseline\", \"middle\"),\n            svg.prop(\"text-anchor\", \"end\"),\n            svg.prop(\"fill\", \"white\")\n          ),\n          string.concat(\"$\", string(svgUtils.round2Txt(avgBalance8Weeks, 6, 2)))\n        )\n      );\n  }\n\n  function renderFooter(\n    address account,\n    uint256 avgBalance8Weeks,\n    string memory emoji,\n    string memory tagline\n  ) internal view returns (string memory) {\n    return\n      string.concat(\n        accountDetails(account, emoji, tagline),\n        renderNetwork(),\n        avgBalanceDetails(avgBalance8Weeks)\n      );\n  }\n\n  function accountDetails(\n    address account,\n    string memory emoji,\n    string memory tagline\n  ) internal view returns (string memory) {\n    return\n      string.concat(\n        svg.text(\n          string.concat(\n            svg.prop(\"x\", \"7.5%\"),\n            svg.prop(\"y\", \"67.5%\"),\n            svg.prop(\"font-size\", \"24\"),\n            svg.prop(\"alignment-baseline\", \"middle\"),\n            svg.prop(\"text-anchor\", \"start\"),\n            svg.prop(\"fill\", \"white\")\n          ),\n          emoji\n        ),\n        svg.text(\n          string.concat(\n            svg.prop(\"x\", \"7.5%\"),\n            svg.prop(\"y\", \"77.5%\"),\n            svg.prop(\"font-size\", \"28\"),\n            svg.prop(\"alignment-baseline\", \"middle\"),\n            svg.prop(\"text-anchor\", \"start\"),\n            svg.prop(\"fill\", \"white\")\n          ),\n          svgUtils.splitAddress(account)\n        ),\n        svg.text(\n          string.concat(\n            svg.prop(\"x\", \"7.5%\"),\n            svg.prop(\"y\", \"87.5%\"),\n            svg.prop(\"font-size\", \"14\"),\n            svg.prop(\"font-weight\", \"300\"),\n            svg.prop(\"alignment-baseline\", \"middle\"),\n            svg.prop(\"text-anchor\", \"start\"),\n            svg.prop(\"fill\", \"white\")\n          ),\n          tagline\n        )\n      );\n  }\n\n  function renderNetwork() internal view returns (string memory) {\n    bytes32 network;\n    string memory name;\n    if (block.chainid == 1) {\n      name = \"Ethereum\";\n      network = BYTES32_ICON_NETWORK_ETHEREUM;\n    } else if (block.chainid == 10) {\n      name = \"Optimism\";\n      network = BYTES32_ICON_NETWORK_OPTIMISM;\n    } else if (block.chainid == 137) {\n      name = \"Polygon\";\n      network = BYTES32_ICON_NETWORK_POLYGON;\n    } else if (block.chainid == 42161) {\n      name = \"Arbitrum\";\n      network = BYTES32_ICON_NETWORK_ARBITRUM;\n    } else {\n      name = \"Unknown\";\n      network = BYTES32_ICON_NETWORK_TEST;\n      // network = BYTES32_ICON_NETWORK_ETHEREUM;\n    }\n\n    return\n      string.concat(\n        svg.text(\n          string.concat(\n            svg.prop(\"x\", \"85%\"),\n            svg.prop(\"y\", \"80%\"),\n            svg.prop(\"font-size\", \"18\"),\n            svg.prop(\"alignment-baseline\", \"middle\"),\n            svg.prop(\"text-anchor\", \"end\"),\n            svg.prop(\"fill\", \"white\")\n          ),\n          name\n        ),\n        svg.g(\n          string.concat(svg.prop(\"transform\", \"translate(440,225)\")),\n          _registry(BYTES32_WEB3_ASSETS, abi.encode(network))\n        )\n      );\n  }\n\n  function _lib(bytes32 _key, bytes memory _value) internal view returns (string memory) {\n    return SVGLibrary(svgLibrary).execute(_key, _value);\n  }\n\n  function _registry(bytes32 _key, bytes memory _value) internal view returns (string memory) {\n    return SVGRegistry(svgRegistry).fetch(_key, _value);\n  }\n}\n"
    },
    "contracts/PoolTogether/twab/ExtendedSafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.15;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary ExtendedSafeCastLib {\n  /**\n   * @dev Returns the downcasted uint104 from uint256, reverting on\n   * overflow (when the input is greater than largest uint104).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   */\n  function toUint104(uint256 _value) internal pure returns (uint104) {\n    require(_value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n    return uint104(_value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint208 from uint256, reverting on\n   * overflow (when the input is greater than largest uint208).\n   *\n   * Counterpart to Solidity's `uint208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   */\n  function toUint208(uint256 _value) internal pure returns (uint208) {\n    require(_value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n    return uint208(_value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 _value) internal pure returns (uint224) {\n    require(_value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return uint224(_value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint192 from uint256, reverting on\n   * overflow (when the input is greater than largest uint192).\n   *\n   * Counterpart to Solidity's `uint192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint192(uint256 value) internal pure returns (uint192) {\n    require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n    return uint192(value);\n  }\n}\n"
    },
    "contracts/PoolTogether/twab/ObservationLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.15;\n\nimport {SafeCastLib} from \"../../Solbase/SafeCastLib.sol\";\nimport \"./OverflowSafeComparatorLib.sol\";\nimport \"./RingBufferLib.sol\";\n\n/**\n * @title Observation Library\n * @notice This library allows one to store an array of timestamped values and efficiently binary search them.\n * @dev Largely pulled from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/c05a0e2c8c08c460fb4d05cfdda30b3ad8deeaac/contracts/libraries/Oracle.sol\n * @author PoolTogether Inc.\n */\nlibrary ObservationLib {\n  using OverflowSafeComparatorLib for uint32;\n  using SafeCastLib for uint256;\n\n  /// @notice The maximum number of observations\n  uint24 public constant MAX_CARDINALITY = 16777215; // 2**24\n\n  /**\n   * @notice Observation, which includes an amount and timestamp.\n   * @param amount `amount` at `timestamp`.\n   * @param timestamp Recorded `timestamp`.\n   */\n  struct Observation {\n    uint224 amount;\n    uint32 timestamp;\n  }\n\n  /**\n   * @notice Fetches Observations `beforeOrAt` and `atOrAfter` a `_target`, eg: where [`beforeOrAt`, `atOrAfter`] is satisfied.\n   * The result may be the same Observation, or adjacent Observations.\n   * @dev The answer must be contained in the array used when the target is located within the stored Observation.\n   * boundaries: older than the most recent Observation and younger, or the same age as, the oldest Observation.\n   * @dev  If `_newestObservationIndex` is less than `_oldestObservationIndex`, it means that we've wrapped around the circular buffer.\n   *       So the most recent observation will be at `_oldestObservationIndex + _cardinality - 1`, at the beginning of the circular buffer.\n   * @param _observations List of Observations to search through.\n   * @param _newestObservationIndex Index of the newest Observation. Right side of the circular buffer.\n   * @param _oldestObservationIndex Index of the oldest Observation. Left side of the circular buffer.\n   * @param _target Timestamp at which we are searching the Observation.\n   * @param _cardinality Cardinality of the circular buffer we are searching through.\n   * @param _time Timestamp at which we perform the binary search.\n   * @return beforeOrAt Observation recorded before, or at, the target.\n   * @return atOrAfter Observation recorded at, or after, the target.\n   */\n  function binarySearch(\n    Observation[MAX_CARDINALITY] storage _observations,\n    uint24 _newestObservationIndex,\n    uint24 _oldestObservationIndex,\n    uint32 _target,\n    uint24 _cardinality,\n    uint32 _time\n  ) internal view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n    uint256 leftSide = _oldestObservationIndex;\n    uint256 rightSide = _newestObservationIndex < leftSide\n      ? leftSide + _cardinality - 1\n      : _newestObservationIndex;\n    uint256 currentIndex;\n\n    while (true) {\n      // We start our search in the middle of the `leftSide` and `rightSide`.\n      // After each iteration, we narrow down the search to the left or the right side while still starting our search in the middle.\n      currentIndex = (leftSide + rightSide) / 2;\n\n      beforeOrAt = _observations[uint24(RingBufferLib.wrap(currentIndex, _cardinality))];\n      uint32 beforeOrAtTimestamp = beforeOrAt.timestamp;\n\n      // We've landed on an uninitialized timestamp, keep searching higher (more recently).\n      if (beforeOrAtTimestamp == 0) {\n        leftSide = currentIndex + 1;\n        continue;\n      }\n\n      atOrAfter = _observations[uint24(RingBufferLib.nextIndex(currentIndex, _cardinality))];\n\n      bool targetAtOrAfter = beforeOrAtTimestamp.lte(_target, _time);\n\n      // Check if we've found the corresponding Observation.\n      if (targetAtOrAfter && _target.lte(atOrAfter.timestamp, _time)) {\n        break;\n      }\n\n      // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower. To the left of the current index.\n      if (!targetAtOrAfter) {\n        rightSide = currentIndex - 1;\n      } else {\n        // Otherwise, we keep searching higher. To the left of the current index.\n        leftSide = currentIndex + 1;\n      }\n    }\n  }\n}\n"
    },
    "contracts/PoolTogether/twab/OverflowSafeComparatorLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.15;\n\n/// @title OverflowSafeComparatorLib library to share comparator functions between contracts\n/// @dev Code taken from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/3e88af408132fc957e3e406f65a0ce2b1ca06c3d/contracts/libraries/Oracle.sol\n/// @author PoolTogether Inc.\nlibrary OverflowSafeComparatorLib {\n  /// @notice 32-bit timestamps comparator.\n  /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.\n  /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.\n  /// @param _b Timestamp to compare against `_a`.\n  /// @param _timestamp A timestamp truncated to 32 bits.\n  /// @return bool Whether `_a` is chronologically < `_b`.\n  function lt(\n    uint32 _a,\n    uint32 _b,\n    uint32 _timestamp\n  ) internal pure returns (bool) {\n    // No need to adjust if there hasn't been an overflow\n    if (_a <= _timestamp && _b <= _timestamp) return _a < _b;\n\n    uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\n    uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\n\n    return aAdjusted < bAdjusted;\n  }\n\n  /// @notice 32-bit timestamps comparator.\n  /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.\n  /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.\n  /// @param _b Timestamp to compare against `_a`.\n  /// @param _timestamp A timestamp truncated to 32 bits.\n  /// @return bool Whether `_a` is chronologically <= `_b`.\n  function lte(\n    uint32 _a,\n    uint32 _b,\n    uint32 _timestamp\n  ) internal pure returns (bool) {\n    // No need to adjust if there hasn't been an overflow\n    if (_a <= _timestamp && _b <= _timestamp) return _a <= _b;\n\n    uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\n    uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\n\n    return aAdjusted <= bAdjusted;\n  }\n\n  /// @notice 32-bit timestamp subtractor\n  /// @dev safe for 0 or 1 overflows, where `_a` and `_b` must be chronologically before or equal to time\n  /// @param _a The subtraction left operand\n  /// @param _b The subtraction right operand\n  /// @param _timestamp The current time.  Expected to be chronologically after both.\n  /// @return The difference between a and b, adjusted for overflow\n  function checkedSub(\n    uint32 _a,\n    uint32 _b,\n    uint32 _timestamp\n  ) internal pure returns (uint32) {\n    // No need to adjust if there hasn't been an overflow\n\n    if (_a <= _timestamp && _b <= _timestamp) return _a - _b;\n\n    uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\n    uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\n\n    return uint32(aAdjusted - bAdjusted);\n  }\n}\n"
    },
    "contracts/PoolTogether/twab/RingBufferLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.15;\n\nlibrary RingBufferLib {\n  /**\n   * @notice Returns wrapped TWAB index.\n   * @dev  In order to navigate the TWAB circular buffer, we need to use the modulo operator.\n   * @dev  For example, if `_index` is equal to 32 and the TWAB circular buffer is of `_cardinality` 32,\n   *       it will return 0 and will point to the first element of the array.\n   * @param _index Index used to navigate through the TWAB circular buffer.\n   * @param _cardinality TWAB buffer cardinality.\n   * @return TWAB index.\n   */\n  function wrap(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {\n    return _index % _cardinality;\n  }\n\n  /**\n   * @notice Computes the negative offset from the given index, wrapped by the cardinality.\n   * @dev  We add `_cardinality` to `_index` to be able to offset even if `_amount` is superior to `_cardinality`.\n   * @param _index The index from which to offset\n   * @param _amount The number of indices to offset.  This is subtracted from the given index.\n   * @param _cardinality The number of elements in the ring buffer\n   * @return Offsetted index.\n   */\n  function offset(\n    uint256 _index,\n    uint256 _amount,\n    uint256 _cardinality\n  ) internal pure returns (uint256) {\n    return wrap(_index + _cardinality - _amount, _cardinality);\n  }\n\n  /// @notice Returns the index of the last recorded TWAB\n  /// @param _nextIndex The next available twab index.  This will be recorded to next.\n  /// @param _cardinality The cardinality of the TWAB history.\n  /// @return The index of the last recorded TWAB\n  function newestIndex(uint256 _nextIndex, uint256 _cardinality) internal pure returns (uint256) {\n    if (_cardinality == 0) {\n      return 0;\n    }\n\n    return wrap(_nextIndex + _cardinality - 1, _cardinality);\n  }\n\n  /// @notice Computes the ring buffer index that follows the given one, wrapped by cardinality\n  /// @param _index The index to increment\n  /// @param _cardinality The number of elements in the Ring Buffer\n  /// @return The next index relative to the given index.  Will wrap around to 0 if the next index == cardinality\n  function nextIndex(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {\n    return wrap(_index + 1, _cardinality);\n  }\n}\n"
    },
    "contracts/PoolTogether/twab/TwabLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.15;\n\nimport \"./ExtendedSafeCastLib.sol\";\nimport \"./OverflowSafeComparatorLib.sol\";\nimport \"./RingBufferLib.sol\";\nimport \"./ObservationLib.sol\";\n\n/**\n  * @title  PoolTogether V4 TwabLib (Library)\n  * @author PoolTogether Inc Team\n  * @dev    Time-Weighted Average Balance Library for ERC20 tokens.\n  * @notice This TwabLib adds on-chain historical lookups to a user(s) time-weighted average balance.\n            Each user is mapped to an Account struct containing the TWAB history (ring buffer) and\n            ring buffer parameters. Every token.transfer() creates a new TWAB checkpoint. The new TWAB\n            checkpoint is stored in the circular ring buffer, as either a new checkpoint or rewriting\n            a previous checkpoint with new parameters. The TwabLib (using existing blocktimes of 1block/15sec)\n            guarantees minimum 7.4 years of search history.\n */\nlibrary TwabLib {\n  using OverflowSafeComparatorLib for uint32;\n  using ExtendedSafeCastLib for uint256;\n\n  /**\n      * @notice Sets max ring buffer length in the Account.twabs Observation list.\n                As users transfer/mint/burn tickets new Observation checkpoints are\n                recorded. The current max cardinality guarantees a seven year minimum,\n                of accurate historical lookups with current estimates of 1 new block\n                every 15 seconds - assuming each block contains a transfer to trigger an\n                observation write to storage.e\n      * @dev    The user Account.AccountDetails.cardinality parameter can NOT exceed\n                the max cardinality variable. Preventing \"corrupted\" ring buffer lookup\n                pointers and new observation checkpoints.\n\n                The MAX_CARDINALITY in fact guarantees at least 7.4 years of records:\n                If 14 = block time in seconds\n                (2**24) * 14 = 234881024 seconds of history\n                234881024 / (365 * 24 * 60 * 60) ~= 7.44 years\n    */\n  uint24 public constant MAX_CARDINALITY = 16777215; // 2**24\n\n  /** @notice Struct ring buffer parameters for single user Account\n      * @param balance       Current balance for an Account\n      * @param nextTwabIndex Next uninitialized or updatable ring buffer checkpoint storage slot\n      * @param cardinality   Current total \"initialized\" ring buffer checkpoints for single user AccountDetails.\n                             Used to set initial boundary conditions for an efficient binary search.\n    */\n  struct AccountDetails {\n    uint208 balance;\n    uint24 nextTwabIndex;\n    uint24 cardinality;\n  }\n\n  /// @notice Combines account details with their twab history\n  /// @param details The account details\n  /// @param twabs The history of twabs for this account\n  struct Account {\n    AccountDetails details;\n    ObservationLib.Observation[MAX_CARDINALITY] twabs;\n  }\n\n  /// @notice Increases an account's balance and records a new twab.\n  /// @param _account The account whose balance will be increased\n  /// @param _amount The amount to increase the balance by\n  /// @param _currentTime The current time\n  /// @return accountDetails The new AccountDetails\n  /// @return twab The user's latest TWAB\n  /// @return isNew Whether the TWAB is new\n  function increaseBalance(\n    Account storage _account,\n    uint208 _amount,\n    uint32 _currentTime\n  )\n    internal\n    returns (\n      AccountDetails memory accountDetails,\n      ObservationLib.Observation memory twab,\n      bool isNew\n    )\n  {\n    AccountDetails memory _accountDetails = _account.details;\n    (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);\n    accountDetails.balance = _accountDetails.balance + _amount;\n  }\n\n  /** @notice Calculates the next TWAB checkpoint for an account with a decreasing balance.\n   * @dev    With Account struct and amount decreasing calculates the next TWAB observable checkpoint.\n   * @param _account        Account whose balance will be decreased\n   * @param _amount         Amount to decrease the balance by\n   * @param _revertMessage  Revert message for insufficient balance\n   * @return accountDetails Updated Account.details struct\n   * @return twab           TWAB observation (with decreasing average)\n   * @return isNew          Whether TWAB is new or calling twice in the same block\n   */\n  function decreaseBalance(\n    Account storage _account,\n    uint208 _amount,\n    string memory _revertMessage,\n    uint32 _currentTime\n  )\n    internal\n    returns (\n      AccountDetails memory accountDetails,\n      ObservationLib.Observation memory twab,\n      bool isNew\n    )\n  {\n    AccountDetails memory _accountDetails = _account.details;\n\n    require(_accountDetails.balance >= _amount, _revertMessage);\n\n    (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);\n    unchecked {\n      accountDetails.balance -= _amount;\n    }\n  }\n\n  /** @notice Calculates the average balance held by a user for a given time frame.\n      * @dev    Finds the average balance between start and end timestamp epochs.\n                Validates the supplied end time is within the range of elapsed time i.e. less then timestamp of now.\n      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer\n      * @param _accountDetails User AccountDetails struct loaded in memory\n      * @param _startTime      Start of timestamp range as an epoch\n      * @param _endTime        End of timestamp range as an epoch\n      * @param _currentTime    Block.timestamp\n      * @return Average balance of user held between epoch timestamps start and end\n    */\n  function getAverageBalanceBetween(\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\n    AccountDetails memory _accountDetails,\n    uint32 _startTime,\n    uint32 _endTime,\n    uint32 _currentTime\n  ) internal view returns (uint256) {\n    uint32 endTime = _endTime > _currentTime ? _currentTime : _endTime;\n\n    return _getAverageBalanceBetween(_twabs, _accountDetails, _startTime, endTime, _currentTime);\n  }\n\n  /// @notice Retrieves the oldest TWAB\n  /// @param _twabs The storage array of twabs\n  /// @param _accountDetails The TWAB account details\n  /// @return index The index of the oldest TWAB in the twabs array\n  /// @return twab The oldest TWAB\n  function oldestTwab(\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\n    AccountDetails memory _accountDetails\n  ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {\n    index = _accountDetails.nextTwabIndex;\n    twab = _twabs[index];\n\n    // If the TWAB is not initialized we go to the beginning of the TWAB circular buffer at index 0\n    if (twab.timestamp == 0) {\n      index = 0;\n      twab = _twabs[0];\n    }\n  }\n\n  /// @notice Retrieves the newest TWAB\n  /// @param _twabs The storage array of twabs\n  /// @param _accountDetails The TWAB account details\n  /// @return index The index of the newest TWAB in the twabs array\n  /// @return twab The newest TWAB\n  function newestTwab(\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\n    AccountDetails memory _accountDetails\n  ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {\n    index = uint24(RingBufferLib.newestIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY));\n    twab = _twabs[index];\n  }\n\n  /// @notice Retrieves amount at `_targetTime` timestamp\n  /// @param _twabs List of TWABs to search through.\n  /// @param _accountDetails Accounts details\n  /// @param _targetTime Timestamp at which the reserved TWAB should be for.\n  /// @return uint256 TWAB amount at `_targetTime`.\n  function getBalanceAt(\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\n    AccountDetails memory _accountDetails,\n    uint32 _targetTime,\n    uint32 _currentTime\n  ) internal view returns (uint256) {\n    uint32 timeToTarget = _targetTime > _currentTime ? _currentTime : _targetTime;\n    return _getBalanceAt(_twabs, _accountDetails, timeToTarget, _currentTime);\n  }\n\n  /// @notice Calculates the average balance held by a user for a given time frame.\n  /// @param _startTime The start time of the time frame.\n  /// @param _endTime The end time of the time frame.\n  /// @return The average balance that the user held during the time frame.\n  function _getAverageBalanceBetween(\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\n    AccountDetails memory _accountDetails,\n    uint32 _startTime,\n    uint32 _endTime,\n    uint32 _currentTime\n  ) private view returns (uint256) {\n    (uint24 oldestTwabIndex, ObservationLib.Observation memory oldTwab) = oldestTwab(\n      _twabs,\n      _accountDetails\n    );\n\n    (uint24 newestTwabIndex, ObservationLib.Observation memory newTwab) = newestTwab(\n      _twabs,\n      _accountDetails\n    );\n\n    ObservationLib.Observation memory startTwab = _calculateTwab(\n      _twabs,\n      _accountDetails,\n      newTwab,\n      oldTwab,\n      newestTwabIndex,\n      oldestTwabIndex,\n      _startTime,\n      _currentTime\n    );\n\n    ObservationLib.Observation memory endTwab = _calculateTwab(\n      _twabs,\n      _accountDetails,\n      newTwab,\n      oldTwab,\n      newestTwabIndex,\n      oldestTwabIndex,\n      _endTime,\n      _currentTime\n    );\n\n    // Difference in amount / time\n    return\n      (endTwab.amount - startTwab.amount) /\n      OverflowSafeComparatorLib.checkedSub(endTwab.timestamp, startTwab.timestamp, _currentTime);\n  }\n\n  /** @notice Searches TWAB history and calculate the difference between amount(s)/timestamp(s) to return average balance\n                between the Observations closes to the supplied targetTime.\n      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer\n      * @param _accountDetails User AccountDetails struct loaded in memory\n      * @param _targetTime     Target timestamp to filter Observations in the ring buffer binary search\n      * @param _currentTime    Block.timestamp\n      * @return uint256 Time-weighted average amount between two closest observations.\n    */\n  function _getBalanceAt(\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\n    AccountDetails memory _accountDetails,\n    uint32 _targetTime,\n    uint32 _currentTime\n  ) private view returns (uint256) {\n    uint24 newestTwabIndex;\n    ObservationLib.Observation memory afterOrAt;\n    ObservationLib.Observation memory beforeOrAt;\n    (newestTwabIndex, beforeOrAt) = newestTwab(_twabs, _accountDetails);\n\n    // If `_targetTime` is chronologically after the newest TWAB, we can simply return the current balance\n    if (beforeOrAt.timestamp.lte(_targetTime, _currentTime)) {\n      return _accountDetails.balance;\n    }\n\n    uint24 oldestTwabIndex;\n    // Now, set before to the oldest TWAB\n    (oldestTwabIndex, beforeOrAt) = oldestTwab(_twabs, _accountDetails);\n\n    // If `_targetTime` is chronologically before the oldest TWAB, we can early return\n    if (_targetTime.lt(beforeOrAt.timestamp, _currentTime)) {\n      return 0;\n    }\n\n    // Otherwise, we perform the `binarySearch`\n    (beforeOrAt, afterOrAt) = ObservationLib.binarySearch(\n      _twabs,\n      newestTwabIndex,\n      oldestTwabIndex,\n      _targetTime,\n      _accountDetails.cardinality,\n      _currentTime\n    );\n\n    // Sum the difference in amounts and divide by the difference in timestamps.\n    // The time-weighted average balance uses time measured between two epoch timestamps as\n    // a constaint on the measurement when calculating the time weighted average balance.\n    return\n      (afterOrAt.amount - beforeOrAt.amount) /\n      OverflowSafeComparatorLib.checkedSub(afterOrAt.timestamp, beforeOrAt.timestamp, _currentTime);\n  }\n\n  /** @notice Calculates a user TWAB for a target timestamp using the historical TWAB records.\n                The balance is linearly interpolated: amount differences / timestamp differences\n                using the simple (after.amount - before.amount / end.timestamp - start.timestamp) formula.\n    /** @dev    Binary search in _calculateTwab fails when searching out of bounds. Thus, before\n                searching we exclude target timestamps out of range of newest/oldest TWAB(s).\n                IF a search is before or after the range we \"extrapolate\" a Observation from the expected state.\n      * @param _twabs           Individual user Observation recorded checkpoints passed as storage pointer\n      * @param _accountDetails  User AccountDetails struct loaded in memory\n      * @param _newestTwab      Newest TWAB in history (end of ring buffer)\n      * @param _oldestTwab      Olderst TWAB in history (end of ring buffer)\n      * @param _newestTwabIndex Pointer in ring buffer to newest TWAB\n      * @param _oldestTwabIndex Pointer in ring buffer to oldest TWAB\n      * @param _targetTimestamp Epoch timestamp to calculate for time (T) in the TWAB\n      * @param _time            Block.timestamp\n      * @return accountDetails Updated Account.details struct\n    */\n  function _calculateTwab(\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\n    AccountDetails memory _accountDetails,\n    ObservationLib.Observation memory _newestTwab,\n    ObservationLib.Observation memory _oldestTwab,\n    uint24 _newestTwabIndex,\n    uint24 _oldestTwabIndex,\n    uint32 _targetTimestamp,\n    uint32 _time\n  ) private view returns (ObservationLib.Observation memory) {\n    // If `_targetTimestamp` is chronologically after the newest TWAB, we extrapolate a new one\n    if (_newestTwab.timestamp.lt(_targetTimestamp, _time)) {\n      return _computeNextTwab(_newestTwab, _accountDetails.balance, _targetTimestamp);\n    }\n\n    if (_newestTwab.timestamp == _targetTimestamp) {\n      return _newestTwab;\n    }\n\n    if (_oldestTwab.timestamp == _targetTimestamp) {\n      return _oldestTwab;\n    }\n\n    // If `_targetTimestamp` is chronologically before the oldest TWAB, we create a zero twab\n    if (_targetTimestamp.lt(_oldestTwab.timestamp, _time)) {\n      return ObservationLib.Observation({ amount: 0, timestamp: _targetTimestamp });\n    }\n\n    // Otherwise, both timestamps must be surrounded by twabs.\n    (\n      ObservationLib.Observation memory beforeOrAtStart,\n      ObservationLib.Observation memory afterOrAtStart\n    ) = ObservationLib.binarySearch(\n        _twabs,\n        _newestTwabIndex,\n        _oldestTwabIndex,\n        _targetTimestamp,\n        _accountDetails.cardinality,\n        _time\n      );\n\n    uint224 heldBalance = (afterOrAtStart.amount - beforeOrAtStart.amount) /\n      OverflowSafeComparatorLib.checkedSub(\n        afterOrAtStart.timestamp,\n        beforeOrAtStart.timestamp,\n        _time\n      );\n\n    return _computeNextTwab(beforeOrAtStart, heldBalance, _targetTimestamp);\n  }\n\n  /**\n   * @notice Calculates the next TWAB using the newestTwab and updated balance.\n   * @dev    Storage of the TWAB obersation is managed by the calling function and not _computeNextTwab.\n   * @param _currentTwab    Newest Observation in the Account.twabs list\n   * @param _currentBalance User balance at time of most recent (newest) checkpoint write\n   * @param _time           Current block.timestamp\n   * @return TWAB Observation\n   */\n  function _computeNextTwab(\n    ObservationLib.Observation memory _currentTwab,\n    uint224 _currentBalance,\n    uint32 _time\n  ) private pure returns (ObservationLib.Observation memory) {\n    // New twab amount = last twab amount (or zero) + (current amount * elapsed seconds)\n    return\n      ObservationLib.Observation({\n        amount: _currentTwab.amount +\n          _currentBalance *\n          (_time.checkedSub(_currentTwab.timestamp, _time)),\n        timestamp: _time\n      });\n  }\n\n  /// @notice Sets a new TWAB Observation at the next available index and returns the new account details.\n  /// @dev Note that if _currentTime is before the last observation timestamp, it appears as an overflow\n  /// @param _twabs The twabs array to insert into\n  /// @param _accountDetails The current account details\n  /// @param _currentTime The current time\n  /// @return accountDetails The new account details\n  /// @return twab The newest twab (may or may not be brand-new)\n  /// @return isNew Whether the newest twab was created by this call\n  function _nextTwab(\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\n    AccountDetails memory _accountDetails,\n    uint32 _currentTime\n  )\n    private\n    returns (\n      AccountDetails memory accountDetails,\n      ObservationLib.Observation memory twab,\n      bool isNew\n    )\n  {\n    (, ObservationLib.Observation memory _newestTwab) = newestTwab(_twabs, _accountDetails);\n\n    // if we're in the same block, return\n    if (_newestTwab.timestamp == _currentTime) {\n      return (_accountDetails, _newestTwab, false);\n    }\n\n    ObservationLib.Observation memory newTwab = _computeNextTwab(\n      _newestTwab,\n      _accountDetails.balance,\n      _currentTime\n    );\n\n    _twabs[_accountDetails.nextTwabIndex] = newTwab;\n\n    AccountDetails memory nextAccountDetails = push(_accountDetails);\n\n    return (nextAccountDetails, newTwab, true);\n  }\n\n  /// @notice \"Pushes\" a new element on the AccountDetails ring buffer, and returns the new AccountDetails\n  /// @param _accountDetails The account details from which to pull the cardinality and next index\n  /// @return The new AccountDetails\n  function push(AccountDetails memory _accountDetails)\n    internal\n    pure\n    returns (AccountDetails memory)\n  {\n    _accountDetails.nextTwabIndex = uint24(\n      RingBufferLib.nextIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY)\n    );\n\n    // Prevent the Account specific cardinality from exceeding the MAX_CARDINALITY.\n    // The ring buffer length is limited by MAX_CARDINALITY. IF the account.cardinality\n    // exceeds the max cardinality, new observations would be incorrectly set or the\n    // observation would be out of \"bounds\" of the ring buffer. Once reached the\n    // AccountDetails.cardinality will continue to be equal to max cardinality.\n    if (_accountDetails.cardinality < MAX_CARDINALITY) {\n      _accountDetails.cardinality += 1;\n    }\n\n    return _accountDetails;\n  }\n}\n"
    },
    "contracts/Solbase/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode and decode strings in Base64.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding) internal pure returns (string memory result) {\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, sub(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0230)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                // prettier-ignore\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\n                    \n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    // prettier-ignore\n                    if iszero(lt(ptr, end)) { break }\n                }\n\n                let r := mod(dataLength, 3)\n\n                switch noPadding\n                case 0 {\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\n                    // Write the length of the string.\n                    mstore(result, encodedLength)\n                }\n                default {\n                    // Write the length of the string.\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\n                }\n\n                // Allocate the memory for the string.\n                // Add 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(end, 31), not(31)))\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let end := add(data, dataLength)\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                switch and(dataLength, 3)\n                case 0 {\n                    // If padded.\n                    decodedLength := sub(\n                        decodedLength,\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\n                    )\n                }\n                default {\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                }\n\n                result := mload(0x40)\n\n                // Write the length of the string.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                // prettier-ignore\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n\n                    ptr := add(ptr, 3)\n                    \n                    // prettier-ignore\n                    if iszero(lt(data, end)) { break }\n                }\n\n                // Allocate the memory for the string.\n                // Add 32 + 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\n\n                // Restore the zero slot.\n                mstore(0x60, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/Solbase/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas-optimized implementation of EIP-712 domain separator and digest encoding.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/EIP712.sol)\nabstract contract EIP712 {\n    /// -----------------------------------------------------------------------\n    /// Domain Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    bytes32 internal immutable HASHED_DOMAIN_NAME;\n\n    bytes32 internal immutable HASHED_DOMAIN_VERSION;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(string memory domainName, string memory version) {\n        HASHED_DOMAIN_NAME = keccak256(bytes(domainName));\n\n        HASHED_DOMAIN_VERSION = keccak256(bytes(version));\n\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        INITIAL_CHAIN_ID = block.chainid;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// EIP-712 Logic\n    /// -----------------------------------------------------------------------\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, HASHED_DOMAIN_NAME, HASHED_DOMAIN_VERSION, block.chainid, address(this))\n            );\n    }\n\n    function computeDigest(bytes32 hashStruct) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n    }\n}\n"
    },
    "contracts/Solbase/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Modern, minimalist, and gas-optimized ERC20 implementation.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC20/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20/ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// -----------------------------------------------------------------------\n    /// Metadata Storage\n    /// -----------------------------------------------------------------------\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /// -----------------------------------------------------------------------\n    /// ERC20 Storage\n    /// -----------------------------------------------------------------------\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// ERC20 Logic\n    /// -----------------------------------------------------------------------\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal Mint/Burn Logic\n    /// -----------------------------------------------------------------------\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/Solbase/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC20 } from \"./ERC20.sol\";\nimport { EIP712 } from \"./EIP712.sol\";\n\n/// @notice ERC20 + EIP-2612 implementation.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC20/extensions/ERC20Permit.sol)\nabstract contract ERC20Permit is ERC20, EIP712 {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    error PermitExpired();\n\n    error InvalidSigner();\n\n    /// -----------------------------------------------------------------------\n    /// EIP-2612 Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// -----------------------------------------------------------------------\n    /// EIP-2612 Storage\n    /// -----------------------------------------------------------------------\n\n    mapping(address => uint256) public nonces;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) EIP712(_name, \"1\") {}\n\n    /// -----------------------------------------------------------------------\n    /// EIP-2612 Logic\n    /// -----------------------------------------------------------------------\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) revert PermitExpired();\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                computeDigest(keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))),\n                v,\n                r,\n                s\n            );\n\n            if (recoveredAddress == address(0)) revert InvalidSigner();\n\n            if (recoveredAddress != owner) revert InvalidSigner();\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n}\n"
    },
    "contracts/Solbase/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Modern, minimalist, and gas-optimized ERC721 implementation.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC721.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    error NotMinted();\n\n    error ZeroAddress();\n\n    error NotApproved();\n\n    error WrongFrom();\n\n    error InvalidRecipient();\n\n    error UnsafeRecipient();\n\n    error AlreadyMinted();\n\n    /// -----------------------------------------------------------------------\n    /// Metadata Storage/Logic\n    /// -----------------------------------------------------------------------\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /// -----------------------------------------------------------------------\n    /// ERC721 Balance/Owner Storage\n    /// -----------------------------------------------------------------------\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        if ((owner = _ownerOf[id]) == address(0)) revert NotMinted();\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) revert ZeroAddress();\n        return _balanceOf[owner];\n    }\n\n    /// -----------------------------------------------------------------------\n    /// ERC721 Approval Storage\n    /// -----------------------------------------------------------------------\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// ERC721 Logic\n    /// -----------------------------------------------------------------------\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) revert NotApproved();\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 id) public virtual {\n        if (from != _ownerOf[id]) revert WrongFrom();\n\n        if (to == address(0)) revert InvalidRecipient();\n\n        if (msg.sender != from && !isApprovedForAll[from][msg.sender] && msg.sender != getApproved[id])\n            revert NotApproved();\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0) {\n            if (\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") !=\n                ERC721TokenReceiver.onERC721Received.selector\n            ) revert UnsafeRecipient();\n        }\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public virtual {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0) {\n            if (\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) !=\n                ERC721TokenReceiver.onERC721Received.selector\n            ) revert UnsafeRecipient();\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// ERC165 Logic\n    /// -----------------------------------------------------------------------\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal Mint/Burn Logic\n    /// -----------------------------------------------------------------------\n\n    function _mint(address to, uint256 id) internal virtual {\n        if (to == address(0)) revert InvalidRecipient();\n\n        if (_ownerOf[id] != address(0)) revert AlreadyMinted();\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        if (owner == address(0)) revert NotMinted();\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal Safe Mint Logic\n    /// -----------------------------------------------------------------------\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        if (to.code.length != 0) {\n            if (\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") !=\n                ERC721TokenReceiver.onERC721Received.selector\n            ) revert UnsafeRecipient();\n        }\n    }\n\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n\n        if (to.code.length != 0) {\n            if (\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) !=\n                ERC721TokenReceiver.onERC721Received.selector\n            ) revert UnsafeRecipient();\n        }\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC721.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes calldata) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/Solbase/ERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC721} from \"./ERC721.sol\";\nimport {EIP712} from \"./EIP712.sol\";\n\n/// @notice ERC721 + EIP-2612-style implementation.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC721/extensions/ERC721Permit.sol)\nabstract contract ERC721Permit is ERC721, EIP712 {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    error PermitExpired();\n\n    error InvalidSigner();\n\n    /// -----------------------------------------------------------------------\n    /// EIP-2612-style Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 id,uint256 nonce,uint256 deadline)\")`.\n    bytes32 public constant PERMIT_TYPEHASH = 0x29da74a9365f97c3d77de334aec5c720e44b0c8a6e640ceb375e27a8ab7acadd;\n\n    /// -----------------------------------------------------------------------\n    /// EIP-2612-style Storage\n    /// -----------------------------------------------------------------------\n\n    mapping(uint256 => uint256) public nonces;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) EIP712(_name, \"1\") {}\n\n    /// -----------------------------------------------------------------------\n    /// EIP-2612-style Permit Logic\n    /// -----------------------------------------------------------------------\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 id,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) revert PermitExpired();\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                computeDigest(keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, id, nonces[id]++, deadline))),\n                v,\n                r,\n                s\n            );\n\n            bool isApprovingAll = id == type(uint256).max;\n\n            if (\n                ((!isApprovingAll && recoveredAddress != _ownerOf[id]) && recoveredAddress == address(0)) ||\n                recoveredAddress != owner\n            ) revert InvalidSigner();\n\n            // If id is 2**256, then we assume the signer wants\n            // to approve spender to spend all of their tokens.\n            if (isApprovingAll) {\n                isApprovedForAll[recoveredAddress][spender] = true;\n\n                emit ApprovalForAll(recoveredAddress, spender, true);\n            } else {\n                getApproved[id] = spender;\n\n                emit Approval(recoveredAddress, spender, id);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Solbase/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibString.sol)\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\n\n    /// -----------------------------------------------------------------------\n    /// Decimal Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Hexadecimal Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for {} 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := add(sub(end, str), 2)\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 0x20)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            let m := add(start, 0xa0)\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := add(sub(end, str), 2)\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 0x20)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\n            // and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\n            str := add(start, 0x60)\n\n            // Allocate the memory.\n            mstore(0x40, str)\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let length := 20\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 32)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, 42)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Other String Operations\n    /// -----------------------------------------------------------------------\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\n    function replace(\n        string memory subject,\n        string memory search,\n        string memory replacement\n    ) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        // prettier-ignore\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            // prettier-ignore\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            // prettier-ignore\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            // Zeroize the slot after the string.\n            let last := add(add(result, 0x20), k)\n            mstore(last, 0)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n            // Store the length of the result.\n            mstore(result, k)\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(\n        string memory subject,\n        string memory search,\n        uint256 from\n    ) internal pure returns (uint256 result) {\n        assembly {\n            // prettier-ignore\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    // `result = min(from, subjectLength)`.\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)    \n                \n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(add(search, 0x20))\n\n                // prettier-ignore\n                if iszero(lt(subject, subjectSearchEnd)) { break }\n\n                if iszero(lt(searchLength, 32)) {\n                    // prettier-ignore\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        // prettier-ignore\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\n                    }\n                    break\n                }\n                // prettier-ignore\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(\n        string memory subject,\n        string memory search,\n        uint256 from\n    ) internal pure returns (uint256 result) {\n        assembly {\n            // prettier-ignore\n            for {} 1 {} {\n                let searchLength := mload(search)\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) {\n                    from := fromMax\n                }\n                if iszero(mload(search)) {\n                    result := from\n                    break\n                }\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\n\n                subject := add(add(subject, 0x20), from)\n                // prettier-ignore\n                if iszero(gt(subject, subjectSearchEnd)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                // prettier-ignore\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(subjectSearchEnd, 1))\n                        break\n                    }\n                    subject := sub(subject, 1)\n                    // prettier-ignore\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                // prettier-ignore\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    // prettier-ignore\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        // prettier-ignore\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    // prettier-ignore\n                    if iszero(times) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(output, 0)\n                // Store the length.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(\n        string memory subject,\n        uint256 start,\n        uint256 end\n    ) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) {\n                end := subjectLength\n            }\n            if iszero(gt(subjectLength, start)) {\n                start := subjectLength\n            }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                // Copy the `subject` one word at a time, backwards.\n                // prettier-ignore\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := sub(o, 0x20)\n                    // prettier-ignore\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        assembly {\n            if mload(indices) {\n                let indexPtr := add(indices, 0x20)\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n                mstore(sub(indicesEnd, 0x20), mload(subject))\n                mstore(indices, add(mload(indices), 1))\n                let prevIndex := 0\n                // prettier-ignore\n                for {} 1 {} {\n                    let index := mload(indexPtr)\n                    mstore(indexPtr, 0x60)                        \n                    if iszero(eq(index, prevIndex)) {\n                        let element := mload(0x40)\n                        let elementLength := sub(index, prevIndex)\n                        mstore(element, elementLength)\n                        // Copy the `subject` one word at a time, backwards.\n                        // prettier-ignore\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                            o := sub(o, 0x20)\n                            // prettier-ignore\n                            if iszero(o) { break }\n                        }\n                        // Zeroize the slot after the string.\n                        mstore(add(add(element, 0x20), elementLength), 0)\n                        // Allocate memory for the length and the bytes,\n                        // rounded up to a multiple of 32.\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\n                        // Store the `element` into the array.\n                        mstore(indexPtr, element)                        \n                    }\n                    prevIndex := add(index, mload(delimiter))\n                    indexPtr := add(indexPtr, 0x20)\n                    // prettier-ignore\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\n                }\n                result := indices\n                if iszero(mload(delimiter)) {\n                    result := add(indices, 0x20)\n                    mstore(result, sub(mload(indices), 2))\n                }\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory result) {\n        assembly {\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := sub(o, 0x20)\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := sub(o, 0x20)\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes.\n                mload(add(a, 0x1f)),\n                // `length != 0 && length < 32`. Abuses underflow.\n                // Assumes that the length is valid and within the block gas limit.\n                lt(sub(mload(a), 1), 0x1f)\n            )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes of `a` and `b`.\n                or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                // Assumes that the lengths are valid and within the block gas limit.\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\n            )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(add(a, 0x20), mload(a)), 0)\n            // Store the return offset.\n            // Assumes that the string does not start from the scratch space.\n            mstore(sub(a, 0x20), 0x20)\n            // End the transaction, returning the string.\n            return(sub(a, 0x20), add(mload(a), 0x40))\n        }\n    }\n}\n"
    },
    "contracts/Solbase/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/auth/Owned.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    error Unauthorized();\n\n    /// -----------------------------------------------------------------------\n    /// Ownership Storage\n    /// -----------------------------------------------------------------------\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        if (msg.sender != owner) revert Unauthorized();\n\n        _;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Ownership Logic\n    /// -----------------------------------------------------------------------\n\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "contracts/Solbase/OwnedRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner and multiroles authorization mixin.\n/// @author SolDAO (https://github.com/Sol-DAO/solbase/blob/main/src/auth/OwnedRoles.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/auth/OwnableRoles.sol)\n/// @dev While the ownable portion follows EIP-173 (https://eips.ethereum.org/EIPS/eip-173)\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\n/// may be unique to this codebase.\nabstract contract OwnedRoles {\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev The `user`'s roles is updated to `roles`.\n    /// Each bit of `roles` represents whether the role is set.\n    event RolesUpdated(address indexed user, uint256 indexed roles);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /// @dev `keccak256(bytes(\"RolesUpdated(address,uint256)\"))`.\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\n\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    /// @dev The caller is not authorized to call the function.\n    // error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev `bytes4(keccak256(bytes(\"Unauthorized()\")))`.\n    uint256 private constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;\n\n    /// @dev `bytes4(keccak256(bytes(\"NewOwnerIsZeroAddress()\")))`.\n    uint256 private constant _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR = 0x7448fbae;\n\n    /// @dev `bytes4(keccak256(bytes(\"NoHandoverRequest()\")))`.\n    uint256 private constant _NO_HANDOVER_REQUEST_ERROR_SELECTOR = 0x6f5e8818;\n\n    /// -----------------------------------------------------------------------\n    /// Storage\n    /// -----------------------------------------------------------------------\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally choosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    ///\n    /// The role slot of `user` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n    ///     let roleSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// This automatically ignores the upper bits of the `user` in case\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /// -----------------------------------------------------------------------\n    /// Internal Functions\n    /// -----------------------------------------------------------------------\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Grants the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn on.\n    function _grantRoles(address user, uint256 roles) internal virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            let roleSlot := keccak256(0x00, 0x20)\n            // Load the current value and `or` it with `roles`.\n            let newRoles := or(sload(roleSlot), roles)\n            // Store the new value.\n            sstore(roleSlot, newRoles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, shl(96, user)), newRoles)\n        }\n    }\n\n    /// @dev Removes the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn off.\n    function _removeRoles(address user, uint256 roles) internal virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            let roleSlot := keccak256(0x00, 0x20)\n            // Load the current value.\n            let currentRoles := sload(roleSlot)\n            // Use `and` to compute the intersection of `currentRoles` and `roles`,\n            // `xor` it with `currentRoles` to flip the bits in the intersection.\n            let newRoles := xor(currentRoles, and(currentRoles, roles))\n            // Then, store the new value.\n            sstore(roleSlot, newRoles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, shl(96, user)), newRoles)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Public Update Functions\n    /// -----------------------------------------------------------------------\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Reverts if the `newOwner` is the zero address.\n            if iszero(newOwner) {\n                mstore(0x00, _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), newOwner)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n        }\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        assembly {\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), 0)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), 0)\n        }\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\n            assembly {\n                // Compute and set the handover slot to 1.\n                mstore(0x00, or(shl(96, caller()), _HANDOVER_SLOT_SEED))\n                sstore(keccak256(0x00, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x00, or(shl(96, caller()), _HANDOVER_SLOT_SEED))\n            sstore(keccak256(0x00, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        assembly {\n            // Clean the upper 96 bits.\n            pendingOwner := shr(96, shl(96, pendingOwner))\n            // Compute and set the handover slot to 0.\n            mstore(0x00, or(shl(96, pendingOwner), _HANDOVER_SLOT_SEED))\n            let handoverSlot := keccak256(0x00, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, _NO_HANDOVER_REQUEST_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), pendingOwner)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), pendingOwner)\n        }\n    }\n\n    /// @dev Allows the owner to grant `user` `roles`.\n    /// If the `user` already has a role, then it will be an no-op for the role.\n    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _grantRoles(user, roles);\n    }\n\n    /// @dev Allows the owner to remove `user` `roles`.\n    /// If the `user` does not have a role, then it will be an no-op for the role.\n    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _removeRoles(user, roles);\n    }\n\n    /// @dev Allow the caller to remove their own roles.\n    /// If the caller does not have a role, then it will be an no-op for the role.\n    function renounceRoles(uint256 roles) public payable virtual {\n        _removeRoles(msg.sender, roles);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Public Read Functions\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner) public view virtual returns (uint256 result) {\n        assembly {\n            // Compute the handover slot.\n            mstore(0x00, or(shl(96, pendingOwner), _HANDOVER_SLOT_SEED))\n            // Load the handover slot.\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /// @dev Returns whether `user` has any of `roles`.\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool result) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Load the stored value, and set the result to whether the\n            // `and` intersection of the value and `roles` is not zero.\n            result := iszero(iszero(and(sload(keccak256(0x00, 0x20)), roles)))\n        }\n    }\n\n    /// @dev Returns whether `user` has all of `roles`.\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool result) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Whether the stored value is contains all the set bits in `roles`.\n            result := eq(and(sload(keccak256(0x00, 0x20)), roles), roles)\n        }\n    }\n\n    /// @dev Returns the roles of `user`.\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Load the stored value.\n            roles := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    function rolesFromOrdinals(uint8[] memory ordinals) public pure returns (uint256 roles) {\n        assembly {\n            // Skip the length slot.\n            let o := add(ordinals, 0x20)\n            // `shl` 5 is equivalent to multiplying by 0x20.\n            let end := add(o, shl(5, mload(ordinals)))\n            // prettier-ignore\n            for {} iszero(eq(o, end)) { o := add(o, 0x20) } {\n                roles := or(roles, shl(and(mload(o), 0xff), 1))\n            }\n        }\n    }\n\n    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    function ordinalsFromRoles(uint256 roles) public pure returns (uint8[] memory ordinals) {\n        assembly {\n            // Grab the pointer to the free memory.\n            let ptr := add(mload(0x40), 0x20)\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\n            // smaller bytecode, as this function is not meant to be called on-chain.\n            // prettier-ignore\n            for { let i := 0 } 1 { i := add(i, 1) } {\n                mstore(ptr, i)\n                // `shr` 5 is equivalent to multiplying by 0x20.\n                // Push back into the ordinals array if the bit is set.\n                ptr := add(ptr, shl(5, and(roles, 1)))\n                roles := shr(1, roles)\n                // prettier-ignore\n                if iszero(roles) { break }\n            }\n            // Set `ordinals` to the start of the free memory.\n            ordinals := mload(0x40)\n            // Allocate the memory.\n            mstore(0x40, ptr)\n            // Store the length of `ordinals`.\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Modifiers\n    /// -----------------------------------------------------------------------\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by an account with `roles`.\n    modifier onlyRoles(uint256 roles) virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by the owner or by an account\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\n        assembly {\n            // If the caller is not the stored owner.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                // Compute the role slot.\n                mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n                // Load the stored value, and if the `and` intersection\n                // of the value and `roles` is zero, revert.\n                if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                    mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by an account with `roles`\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                // If the caller is not the stored owner.\n                if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                    mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        _;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Role Constants\n    /// -----------------------------------------------------------------------\n\n    uint256 internal constant _ROLE_0 = 1 << 0;\n    uint256 internal constant _ROLE_1 = 1 << 1;\n    uint256 internal constant _ROLE_2 = 1 << 2;\n    uint256 internal constant _ROLE_3 = 1 << 3;\n    uint256 internal constant _ROLE_4 = 1 << 4;\n    uint256 internal constant _ROLE_5 = 1 << 5;\n    uint256 internal constant _ROLE_6 = 1 << 6;\n    uint256 internal constant _ROLE_7 = 1 << 7;\n    uint256 internal constant _ROLE_8 = 1 << 8;\n    uint256 internal constant _ROLE_9 = 1 << 9;\n    uint256 internal constant _ROLE_10 = 1 << 10;\n    uint256 internal constant _ROLE_11 = 1 << 11;\n    uint256 internal constant _ROLE_12 = 1 << 12;\n    uint256 internal constant _ROLE_13 = 1 << 13;\n    uint256 internal constant _ROLE_14 = 1 << 14;\n    uint256 internal constant _ROLE_15 = 1 << 15;\n    uint256 internal constant _ROLE_16 = 1 << 16;\n    uint256 internal constant _ROLE_17 = 1 << 17;\n    uint256 internal constant _ROLE_18 = 1 << 18;\n    uint256 internal constant _ROLE_19 = 1 << 19;\n    uint256 internal constant _ROLE_20 = 1 << 20;\n    uint256 internal constant _ROLE_21 = 1 << 21;\n    uint256 internal constant _ROLE_22 = 1 << 22;\n    uint256 internal constant _ROLE_23 = 1 << 23;\n    uint256 internal constant _ROLE_24 = 1 << 24;\n    uint256 internal constant _ROLE_25 = 1 << 25;\n    uint256 internal constant _ROLE_26 = 1 << 26;\n    uint256 internal constant _ROLE_27 = 1 << 27;\n    uint256 internal constant _ROLE_28 = 1 << 28;\n    uint256 internal constant _ROLE_29 = 1 << 29;\n    uint256 internal constant _ROLE_30 = 1 << 30;\n    uint256 internal constant _ROLE_31 = 1 << 31;\n    uint256 internal constant _ROLE_32 = 1 << 32;\n    uint256 internal constant _ROLE_33 = 1 << 33;\n    uint256 internal constant _ROLE_34 = 1 << 34;\n    uint256 internal constant _ROLE_35 = 1 << 35;\n    uint256 internal constant _ROLE_36 = 1 << 36;\n    uint256 internal constant _ROLE_37 = 1 << 37;\n    uint256 internal constant _ROLE_38 = 1 << 38;\n    uint256 internal constant _ROLE_39 = 1 << 39;\n    uint256 internal constant _ROLE_40 = 1 << 40;\n    uint256 internal constant _ROLE_41 = 1 << 41;\n    uint256 internal constant _ROLE_42 = 1 << 42;\n    uint256 internal constant _ROLE_43 = 1 << 43;\n    uint256 internal constant _ROLE_44 = 1 << 44;\n    uint256 internal constant _ROLE_45 = 1 << 45;\n    uint256 internal constant _ROLE_46 = 1 << 46;\n    uint256 internal constant _ROLE_47 = 1 << 47;\n    uint256 internal constant _ROLE_48 = 1 << 48;\n    uint256 internal constant _ROLE_49 = 1 << 49;\n    uint256 internal constant _ROLE_50 = 1 << 50;\n    uint256 internal constant _ROLE_51 = 1 << 51;\n    uint256 internal constant _ROLE_52 = 1 << 52;\n    uint256 internal constant _ROLE_53 = 1 << 53;\n    uint256 internal constant _ROLE_54 = 1 << 54;\n    uint256 internal constant _ROLE_55 = 1 << 55;\n    uint256 internal constant _ROLE_56 = 1 << 56;\n    uint256 internal constant _ROLE_57 = 1 << 57;\n    uint256 internal constant _ROLE_58 = 1 << 58;\n    uint256 internal constant _ROLE_59 = 1 << 59;\n    uint256 internal constant _ROLE_60 = 1 << 60;\n    uint256 internal constant _ROLE_61 = 1 << 61;\n    uint256 internal constant _ROLE_62 = 1 << 62;\n    uint256 internal constant _ROLE_63 = 1 << 63;\n    uint256 internal constant _ROLE_64 = 1 << 64;\n    uint256 internal constant _ROLE_65 = 1 << 65;\n    uint256 internal constant _ROLE_66 = 1 << 66;\n    uint256 internal constant _ROLE_67 = 1 << 67;\n    uint256 internal constant _ROLE_68 = 1 << 68;\n    uint256 internal constant _ROLE_69 = 1 << 69;\n    uint256 internal constant _ROLE_70 = 1 << 70;\n    uint256 internal constant _ROLE_71 = 1 << 71;\n    uint256 internal constant _ROLE_72 = 1 << 72;\n    uint256 internal constant _ROLE_73 = 1 << 73;\n    uint256 internal constant _ROLE_74 = 1 << 74;\n    uint256 internal constant _ROLE_75 = 1 << 75;\n    uint256 internal constant _ROLE_76 = 1 << 76;\n    uint256 internal constant _ROLE_77 = 1 << 77;\n    uint256 internal constant _ROLE_78 = 1 << 78;\n    uint256 internal constant _ROLE_79 = 1 << 79;\n    uint256 internal constant _ROLE_80 = 1 << 80;\n    uint256 internal constant _ROLE_81 = 1 << 81;\n    uint256 internal constant _ROLE_82 = 1 << 82;\n    uint256 internal constant _ROLE_83 = 1 << 83;\n    uint256 internal constant _ROLE_84 = 1 << 84;\n    uint256 internal constant _ROLE_85 = 1 << 85;\n    uint256 internal constant _ROLE_86 = 1 << 86;\n    uint256 internal constant _ROLE_87 = 1 << 87;\n    uint256 internal constant _ROLE_88 = 1 << 88;\n    uint256 internal constant _ROLE_89 = 1 << 89;\n    uint256 internal constant _ROLE_90 = 1 << 90;\n    uint256 internal constant _ROLE_91 = 1 << 91;\n    uint256 internal constant _ROLE_92 = 1 << 92;\n    uint256 internal constant _ROLE_93 = 1 << 93;\n    uint256 internal constant _ROLE_94 = 1 << 94;\n    uint256 internal constant _ROLE_95 = 1 << 95;\n    uint256 internal constant _ROLE_96 = 1 << 96;\n    uint256 internal constant _ROLE_97 = 1 << 97;\n    uint256 internal constant _ROLE_98 = 1 << 98;\n    uint256 internal constant _ROLE_99 = 1 << 99;\n    uint256 internal constant _ROLE_100 = 1 << 100;\n    uint256 internal constant _ROLE_101 = 1 << 101;\n    uint256 internal constant _ROLE_102 = 1 << 102;\n    uint256 internal constant _ROLE_103 = 1 << 103;\n    uint256 internal constant _ROLE_104 = 1 << 104;\n    uint256 internal constant _ROLE_105 = 1 << 105;\n    uint256 internal constant _ROLE_106 = 1 << 106;\n    uint256 internal constant _ROLE_107 = 1 << 107;\n    uint256 internal constant _ROLE_108 = 1 << 108;\n    uint256 internal constant _ROLE_109 = 1 << 109;\n    uint256 internal constant _ROLE_110 = 1 << 110;\n    uint256 internal constant _ROLE_111 = 1 << 111;\n    uint256 internal constant _ROLE_112 = 1 << 112;\n    uint256 internal constant _ROLE_113 = 1 << 113;\n    uint256 internal constant _ROLE_114 = 1 << 114;\n    uint256 internal constant _ROLE_115 = 1 << 115;\n    uint256 internal constant _ROLE_116 = 1 << 116;\n    uint256 internal constant _ROLE_117 = 1 << 117;\n    uint256 internal constant _ROLE_118 = 1 << 118;\n    uint256 internal constant _ROLE_119 = 1 << 119;\n    uint256 internal constant _ROLE_120 = 1 << 120;\n    uint256 internal constant _ROLE_121 = 1 << 121;\n    uint256 internal constant _ROLE_122 = 1 << 122;\n    uint256 internal constant _ROLE_123 = 1 << 123;\n    uint256 internal constant _ROLE_124 = 1 << 124;\n    uint256 internal constant _ROLE_125 = 1 << 125;\n    uint256 internal constant _ROLE_126 = 1 << 126;\n    uint256 internal constant _ROLE_127 = 1 << 127;\n    uint256 internal constant _ROLE_128 = 1 << 128;\n    uint256 internal constant _ROLE_129 = 1 << 129;\n    uint256 internal constant _ROLE_130 = 1 << 130;\n    uint256 internal constant _ROLE_131 = 1 << 131;\n    uint256 internal constant _ROLE_132 = 1 << 132;\n    uint256 internal constant _ROLE_133 = 1 << 133;\n    uint256 internal constant _ROLE_134 = 1 << 134;\n    uint256 internal constant _ROLE_135 = 1 << 135;\n    uint256 internal constant _ROLE_136 = 1 << 136;\n    uint256 internal constant _ROLE_137 = 1 << 137;\n    uint256 internal constant _ROLE_138 = 1 << 138;\n    uint256 internal constant _ROLE_139 = 1 << 139;\n    uint256 internal constant _ROLE_140 = 1 << 140;\n    uint256 internal constant _ROLE_141 = 1 << 141;\n    uint256 internal constant _ROLE_142 = 1 << 142;\n    uint256 internal constant _ROLE_143 = 1 << 143;\n    uint256 internal constant _ROLE_144 = 1 << 144;\n    uint256 internal constant _ROLE_145 = 1 << 145;\n    uint256 internal constant _ROLE_146 = 1 << 146;\n    uint256 internal constant _ROLE_147 = 1 << 147;\n    uint256 internal constant _ROLE_148 = 1 << 148;\n    uint256 internal constant _ROLE_149 = 1 << 149;\n    uint256 internal constant _ROLE_150 = 1 << 150;\n    uint256 internal constant _ROLE_151 = 1 << 151;\n    uint256 internal constant _ROLE_152 = 1 << 152;\n    uint256 internal constant _ROLE_153 = 1 << 153;\n    uint256 internal constant _ROLE_154 = 1 << 154;\n    uint256 internal constant _ROLE_155 = 1 << 155;\n    uint256 internal constant _ROLE_156 = 1 << 156;\n    uint256 internal constant _ROLE_157 = 1 << 157;\n    uint256 internal constant _ROLE_158 = 1 << 158;\n    uint256 internal constant _ROLE_159 = 1 << 159;\n    uint256 internal constant _ROLE_160 = 1 << 160;\n    uint256 internal constant _ROLE_161 = 1 << 161;\n    uint256 internal constant _ROLE_162 = 1 << 162;\n    uint256 internal constant _ROLE_163 = 1 << 163;\n    uint256 internal constant _ROLE_164 = 1 << 164;\n    uint256 internal constant _ROLE_165 = 1 << 165;\n    uint256 internal constant _ROLE_166 = 1 << 166;\n    uint256 internal constant _ROLE_167 = 1 << 167;\n    uint256 internal constant _ROLE_168 = 1 << 168;\n    uint256 internal constant _ROLE_169 = 1 << 169;\n    uint256 internal constant _ROLE_170 = 1 << 170;\n    uint256 internal constant _ROLE_171 = 1 << 171;\n    uint256 internal constant _ROLE_172 = 1 << 172;\n    uint256 internal constant _ROLE_173 = 1 << 173;\n    uint256 internal constant _ROLE_174 = 1 << 174;\n    uint256 internal constant _ROLE_175 = 1 << 175;\n    uint256 internal constant _ROLE_176 = 1 << 176;\n    uint256 internal constant _ROLE_177 = 1 << 177;\n    uint256 internal constant _ROLE_178 = 1 << 178;\n    uint256 internal constant _ROLE_179 = 1 << 179;\n    uint256 internal constant _ROLE_180 = 1 << 180;\n    uint256 internal constant _ROLE_181 = 1 << 181;\n    uint256 internal constant _ROLE_182 = 1 << 182;\n    uint256 internal constant _ROLE_183 = 1 << 183;\n    uint256 internal constant _ROLE_184 = 1 << 184;\n    uint256 internal constant _ROLE_185 = 1 << 185;\n    uint256 internal constant _ROLE_186 = 1 << 186;\n    uint256 internal constant _ROLE_187 = 1 << 187;\n    uint256 internal constant _ROLE_188 = 1 << 188;\n    uint256 internal constant _ROLE_189 = 1 << 189;\n    uint256 internal constant _ROLE_190 = 1 << 190;\n    uint256 internal constant _ROLE_191 = 1 << 191;\n    uint256 internal constant _ROLE_192 = 1 << 192;\n    uint256 internal constant _ROLE_193 = 1 << 193;\n    uint256 internal constant _ROLE_194 = 1 << 194;\n    uint256 internal constant _ROLE_195 = 1 << 195;\n    uint256 internal constant _ROLE_196 = 1 << 196;\n    uint256 internal constant _ROLE_197 = 1 << 197;\n    uint256 internal constant _ROLE_198 = 1 << 198;\n    uint256 internal constant _ROLE_199 = 1 << 199;\n    uint256 internal constant _ROLE_200 = 1 << 200;\n    uint256 internal constant _ROLE_201 = 1 << 201;\n    uint256 internal constant _ROLE_202 = 1 << 202;\n    uint256 internal constant _ROLE_203 = 1 << 203;\n    uint256 internal constant _ROLE_204 = 1 << 204;\n    uint256 internal constant _ROLE_205 = 1 << 205;\n    uint256 internal constant _ROLE_206 = 1 << 206;\n    uint256 internal constant _ROLE_207 = 1 << 207;\n    uint256 internal constant _ROLE_208 = 1 << 208;\n    uint256 internal constant _ROLE_209 = 1 << 209;\n    uint256 internal constant _ROLE_210 = 1 << 210;\n    uint256 internal constant _ROLE_211 = 1 << 211;\n    uint256 internal constant _ROLE_212 = 1 << 212;\n    uint256 internal constant _ROLE_213 = 1 << 213;\n    uint256 internal constant _ROLE_214 = 1 << 214;\n    uint256 internal constant _ROLE_215 = 1 << 215;\n    uint256 internal constant _ROLE_216 = 1 << 216;\n    uint256 internal constant _ROLE_217 = 1 << 217;\n    uint256 internal constant _ROLE_218 = 1 << 218;\n    uint256 internal constant _ROLE_219 = 1 << 219;\n    uint256 internal constant _ROLE_220 = 1 << 220;\n    uint256 internal constant _ROLE_221 = 1 << 221;\n    uint256 internal constant _ROLE_222 = 1 << 222;\n    uint256 internal constant _ROLE_223 = 1 << 223;\n    uint256 internal constant _ROLE_224 = 1 << 224;\n    uint256 internal constant _ROLE_225 = 1 << 225;\n    uint256 internal constant _ROLE_226 = 1 << 226;\n    uint256 internal constant _ROLE_227 = 1 << 227;\n    uint256 internal constant _ROLE_228 = 1 << 228;\n    uint256 internal constant _ROLE_229 = 1 << 229;\n    uint256 internal constant _ROLE_230 = 1 << 230;\n    uint256 internal constant _ROLE_231 = 1 << 231;\n    uint256 internal constant _ROLE_232 = 1 << 232;\n    uint256 internal constant _ROLE_233 = 1 << 233;\n    uint256 internal constant _ROLE_234 = 1 << 234;\n    uint256 internal constant _ROLE_235 = 1 << 235;\n    uint256 internal constant _ROLE_236 = 1 << 236;\n    uint256 internal constant _ROLE_237 = 1 << 237;\n    uint256 internal constant _ROLE_238 = 1 << 238;\n    uint256 internal constant _ROLE_239 = 1 << 239;\n    uint256 internal constant _ROLE_240 = 1 << 240;\n    uint256 internal constant _ROLE_241 = 1 << 241;\n    uint256 internal constant _ROLE_242 = 1 << 242;\n    uint256 internal constant _ROLE_243 = 1 << 243;\n    uint256 internal constant _ROLE_244 = 1 << 244;\n    uint256 internal constant _ROLE_245 = 1 << 245;\n    uint256 internal constant _ROLE_246 = 1 << 246;\n    uint256 internal constant _ROLE_247 = 1 << 247;\n    uint256 internal constant _ROLE_248 = 1 << 248;\n    uint256 internal constant _ROLE_249 = 1 << 249;\n    uint256 internal constant _ROLE_250 = 1 << 250;\n    uint256 internal constant _ROLE_251 = 1 << 251;\n    uint256 internal constant _ROLE_252 = 1 << 252;\n    uint256 internal constant _ROLE_253 = 1 << 253;\n    uint256 internal constant _ROLE_254 = 1 << 254;\n    uint256 internal constant _ROLE_255 = 1 << 255;\n}\n"
    },
    "contracts/Solbase/OwnedThreeStep.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Three-step single owner authorization mixin.\n/// @author SolBase (https://github.com/Sol-DAO/Solbase/blob/main/src/auth/OwnedThreeStep.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract OwnedThreeStep {\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event OwnerUpdateInitiated(address indexed user, address indexed ownerCandidate);\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    error Unauthorized();\n\n    /// -----------------------------------------------------------------------\n    /// Ownership Storage\n    /// -----------------------------------------------------------------------\n\n    address public owner;\n\n    address internal _ownerCandidate;\n\n    bool internal _ownerCandidateConfirmed;\n\n    modifier onlyOwner() virtual {\n        if (msg.sender != owner) revert Unauthorized();\n\n        _;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    /// @notice Create contract and set `owner`.\n    /// @param _owner The `owner` of contract.\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Ownership Logic\n    /// -----------------------------------------------------------------------\n\n    /// @notice Initiate ownership transfer.\n    /// @param newOwner The `_ownerCandidate` that will `confirmOwner()`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        _ownerCandidate = newOwner;\n\n        emit OwnerUpdateInitiated(msg.sender, newOwner);\n    }\n\n    /// @notice Confirm ownership between `owner` and `_ownerCandidate`.\n    function confirmOwner() public payable virtual {\n        if (_ownerCandidateConfirmed) {\n            if (msg.sender != owner) revert Unauthorized();\n\n            delete _ownerCandidateConfirmed;\n\n            address newOwner = _ownerCandidate;\n\n            owner = newOwner;\n\n            emit OwnershipTransferred(msg.sender, newOwner);\n        } else {\n            if (msg.sender != _ownerCandidate) revert Unauthorized();\n\n            _ownerCandidateConfirmed = true;\n        }\n    }\n\n    /// @notice Terminate ownership by `owner`.\n    function renounceOwner() public payable virtual onlyOwner {\n        delete owner;\n\n        emit OwnershipTransferred(msg.sender, address(0));\n    }\n}\n"
    },
    "contracts/Solbase/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\nlibrary SafeCastLib {\n    error OverFlow();\n\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        if (x >= (1 << 248)) revert OverFlow();\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        if (x >= (1 << 224)) revert OverFlow();\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        if (x >= (1 << 192)) revert OverFlow();\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        if (x >= (1 << 160)) revert OverFlow();\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        if (x >= (1 << 128)) revert OverFlow();\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        if (x >= (1 << 96)) revert OverFlow();\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        if (x >= (1 << 64)) revert OverFlow();\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        if (x >= (1 << 32)) revert OverFlow();\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        if (x >= (1 << 24)) revert OverFlow();\n\n        y = uint24(x);\n    }\n\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\n        if (x >= (1 << 16)) revert OverFlow();\n\n        y = uint16(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        if (x >= (1 << 8)) revert OverFlow();\n\n        y = uint8(x);\n    }\n}\n"
    },
    "contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Library to encode and decode strings in Base64.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding) internal pure returns (string memory result) {\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, sub(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0230)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                // prettier-ignore\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\n                    \n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    // prettier-ignore\n                    if iszero(lt(ptr, end)) { break }\n                }\n\n                let r := mod(dataLength, 3)\n\n                switch noPadding\n                case 0 {\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\n                    // Write the length of the string.\n                    mstore(result, encodedLength)\n                }\n                default {\n                    // Write the length of the string.\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\n                }\n\n                // Allocate the memory for the string.\n                // Add 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(end, 31), not(31)))\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let end := add(data, dataLength)\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                switch and(dataLength, 3)\n                case 0 {\n                    // If padded.\n                    decodedLength := sub(\n                        decodedLength,\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\n                    )\n                }\n                default {\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                }\n\n                result := mload(0x40)\n\n                // Write the length of the string.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                // prettier-ignore\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n\n                    ptr := add(ptr, 3)\n                    \n                    // prettier-ignore\n                    if iszero(lt(data, end)) { break }\n                }\n\n                // Allocate the memory for the string.\n                // Add 32 + 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\n\n                // Restore the zero slot.\n                mstore(0x60, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/Bytes32AddressLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "contracts/utils/Clone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Class with helper read functions for clone with immutable args.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/Clone.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)\nabstract contract Clone {\n    /// @dev Reads an immutable arg with type bytes.\n    function _getArgBytes(uint256 argOffset, uint256 length) internal pure returns (bytes memory arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        assembly {\n            // Grab the free memory pointer.\n            arg := mload(0x40)\n            // Store the array length.\n            mstore(arg, length)\n            // Copy the array.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)\n            // Allocate the memory, rounded up to the next 32 byte boudnary.\n            mstore(0x40, and(add(add(arg, 0x3f), length), not(0x1f)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type address.\n    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        assembly {\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint256\n    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }\n\n    /// @dev Reads a uint256 array stored in the immutable args.\n    function _getArgUint256Array(uint256 argOffset, uint256 length) internal pure returns (uint256[] memory arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        assembly {\n            // Grab the free memory pointer.\n            arg := mload(0x40)\n            // Store the array length.\n            mstore(arg, length)\n            // Copy the array.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\n            // Allocate the memory.\n            mstore(0x40, add(add(arg, 0x20), shl(5, length)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint64.\n    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        assembly {\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint8.\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        assembly {\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @return offset The offset of the packed immutable args in calldata.\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\n        assembly {\n            offset := sub(calldatasize(), shr(0xf0, calldataload(sub(calldatasize(), 2))))\n        }\n    }\n}\n"
    },
    "contracts/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/CREATE3.sol)\nlibrary CREATE3 {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    error DeploymentFailed();\n\n    error InitializationFailed();\n\n    /// -----------------------------------------------------------------------\n    /// Bytecode Constants\n    /// -----------------------------------------------------------------------\n\n    /**\n     * -------------------------------------------------------------------+\n     * Opcode      | Mnemonic         | Stack        | Memory             |\n     * -------------------------------------------------------------------|\n     * 36          | CALLDATASIZE     | cds          |                    |\n     * 3d          | RETURNDATASIZE   | 0 cds        |                    |\n     * 3d          | RETURNDATASIZE   | 0 0          |                    |\n     * 37          | CALLDATACOPY     |              | [0..cds): calldata |\n     * 36          | CALLDATASIZE     | cds          | [0..cds): calldata |\n     * 3d          | RETURNDATASIZE   | 0 cds        | [0..cds): calldata |\n     * 34          | CALLVALUE        | value 0 cds  | [0..cds): calldata |\n     * f0          | CREATE           | newContract  | [0..cds): calldata |\n     * -------------------------------------------------------------------|\n     * Opcode      | Mnemonic         | Stack        | Memory             |\n     * -------------------------------------------------------------------|\n     * 67 bytecode | PUSH8 bytecode   | bytecode     |                    |\n     * 3d          | RETURNDATASIZE   | 0 bytecode   |                    |\n     * 52          | MSTORE           |              | [0..8): bytecode   |\n     * 60 0x08     | PUSH1 0x08       | 0x08         | [0..8): bytecode   |\n     * 60 0x18     | PUSH1 0x18       | 0x18 0x08    | [0..8): bytecode   |\n     * f3          | RETURN           |              | [0..8): bytecode   |\n     * -------------------------------------------------------------------+\n     */\n\n    uint256 private constant _PROXY_BYTECODE = 0x67363d3d37363d34f03d5260086018f3;\n\n    bytes32 private constant _PROXY_BYTECODE_HASH = 0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\n\n    /// -----------------------------------------------------------------------\n    /// Create3 Operations\n    /// -----------------------------------------------------------------------\n\n    function deploy(bytes32 salt, bytes memory creationCode, uint256 value) internal returns (address deployed) {\n        assembly {\n            // Store the `_PROXY_BYTECODE` into scratch space.\n            mstore(0x00, _PROXY_BYTECODE)\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            let proxy := create2(0, 0x10, 0x10, salt)\n\n            // If the result of `create2` is the zero address, revert.\n            if iszero(proxy) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the proxy's address.\n            mstore(0x14, proxy)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the proxy contract (1).\n            mstore8(0x34, 0x01)\n\n            deployed := keccak256(0x1e, 0x17)\n\n            // If the `call` fails, revert.\n            if iszero(\n                call(\n                    gas(), // Gas remaining.\n                    proxy, // Proxy's address.\n                    value, // Ether value.\n                    add(creationCode, 0x20), // Start of `creationCode`.\n                    mload(creationCode), // Length of `creationCode`.\n                    0x00, // Offset of output.\n                    0x00 // Length of output.\n                )\n            ) {\n                // Store the function selector of `InitializationFailed()`.\n                mstore(0x00, 0x19b991a8)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If the code size of `deployed` is zero, revert.\n            if iszero(extcodesize(deployed)) {\n                // Store the function selector of `InitializationFailed()`.\n                mstore(0x00, 0x19b991a8)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address deployed) {\n        assembly {\n            // Cache the free memory pointer.\n            let m := mload(0x40)\n            // Store `address(this)`.\n            mstore(0x00, address())\n            // Store the prefix.\n            mstore8(0x0b, 0xff)\n            // Store the salt.\n            mstore(0x20, salt)\n            // Store the bytecode hash.\n            mstore(0x40, _PROXY_BYTECODE_HASH)\n\n            // Store the proxy's address.\n            mstore(0x14, keccak256(0x0b, 0x55))\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the proxy contract (1).\n            mstore8(0x34, 0x01)\n\n            deployed := keccak256(0x1e, 0x17)\n        }\n    }\n}\n"
    },
    "contracts/utils/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Gas-optimized ECDSA wrapper.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\nlibrary ECDSA {\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev The number which `s` must not exceed in order for\n    /// the signature to be non-malleable.\n    bytes32 internal constant MALLEABILITY_THRESHOLD =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0;\n\n    /// -----------------------------------------------------------------------\n    /// Recovery Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address result) {\n        assembly {\n            if eq(signature.length, 65) {\n                // Copy the free memory pointer so that we can restore it later.\n                let m := mload(0x40)\n                // Directly copy `r` and `s` from the calldata.\n                calldatacopy(0x40, signature.offset, 0x40)\n\n                // If `s` in lower half order, such that the signature is not malleable.\n                if iszero(gt(mload(0x60), MALLEABILITY_THRESHOLD)) {\n                    mstore(0x00, hash)\n                    // Compute `v` and store it in the scratch space.\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40))))\n                    pop(\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            0x01, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x40, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    )\n                    // Restore the zero slot.\n                    mstore(0x60, 0)\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    result := mload(sub(0x60, returndatasize()))\n                }\n                // Restore the free memory pointer.\n                mstore(0x40, m)\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    ///\n    /// This function only accepts EIP-2098 short form signatures.\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\n    ///\n    /// To be honest, I do not recommend using EIP-2098 signatures\n    /// for simplicity, performance, and security reasons. Most if not\n    /// all clients support traditional non EIP-2098 signatures by default.\n    /// As such, this method is intentionally not fully inlined.\n    /// It is merely included for completeness.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        uint8 v;\n        bytes32 s;\n        assembly {\n            s := shr(1, shl(1, vs))\n            v := add(shr(255, vs), 27)\n        }\n        result = recover(hash, v, r, s);\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal view returns (address result) {\n        assembly {\n            // Copy the free memory pointer so that we can restore it later.\n            let m := mload(0x40)\n\n            // If `s` in lower half order, such that the signature is not malleable.\n            if iszero(gt(s, MALLEABILITY_THRESHOLD)) {\n                mstore(0x00, hash)\n                mstore(0x20, v)\n                mstore(0x40, r)\n                mstore(0x60, s)\n                pop(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        0x01, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x40, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n                // Restore the zero slot.\n                mstore(0x60, 0)\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(sub(0x60, returndatasize()))\n            }\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Hashing Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        assembly {\n            // Store into scratch space for keccak256.\n            mstore(0x20, hash)\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\")\n            // 0x40 - 0x04 = 0x3c\n            result := keccak256(0x04, 0x3c)\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        assembly {\n            // We need at most 128 bytes for Ethereum signed message header.\n            // The max length of the ASCII reprenstation of a uint256 is 78 bytes.\n            // The length of \"\\x19Ethereum Signed Message:\\n\" is 26 bytes (i.e. 0x1a).\n            // The next multiple of 32 above 78 + 26 is 128 (i.e. 0x80).\n\n            // Instead of allocating, we temporarily copy the 128 bytes before the\n            // start of `s` data to some variables.\n            let m3 := mload(sub(s, 0x60))\n            let m2 := mload(sub(s, 0x40))\n            let m1 := mload(sub(s, 0x20))\n            // The length of `s` is in bytes.\n            let sLength := mload(s)\n\n            let ptr := add(s, 0x20)\n\n            // `end` marks the end of the memory which we will compute the keccak256 of.\n            let end := add(ptr, sLength)\n\n            // Convert the length of the bytes to ASCII decimal representation\n            // and store it into the memory.\n            // prettier-ignore\n            for { let temp := sLength } 1 {} {\n                ptr := sub(ptr, 1)\n                mstore8(ptr, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Copy the header over to the memory.\n            mstore(sub(ptr, 0x20), \"\\x00\\x00\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n\")\n            // Compute the keccak256 of the memory.\n            result := keccak256(sub(ptr, 0x1a), sub(end, sub(ptr, 0x1a)))\n\n            // Restore the previous memory.\n            mstore(s, sLength)\n            mstore(sub(s, 0x20), m1)\n            mstore(sub(s, 0x40), m2)\n            mstore(sub(s, 0x60), m3)\n        }\n    }\n}\n"
    },
    "contracts/utils/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Gas-optimized implementation of EIP-712 domain separator and digest encoding.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/EIP712.sol)\nabstract contract EIP712 {\n    /// -----------------------------------------------------------------------\n    /// Domain Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    bytes32 internal immutable HASHED_DOMAIN_NAME;\n\n    bytes32 internal immutable HASHED_DOMAIN_VERSION;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(string memory domainName, string memory version) {\n        HASHED_DOMAIN_NAME = keccak256(bytes(domainName));\n\n        HASHED_DOMAIN_VERSION = keccak256(bytes(version));\n\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        INITIAL_CHAIN_ID = block.chainid;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// EIP-712 Logic\n    /// -----------------------------------------------------------------------\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, HASHED_DOMAIN_NAME, HASHED_DOMAIN_VERSION, block.chainid, address(this))\n            );\n    }\n\n    function computeDigest(bytes32 hashStruct) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n    }\n}\n"
    },
    "contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Interface for contracts with ERC165 support.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibERC165.sol)\nabstract contract ERC165 {\n    function supportsInterface(bytes4 interfaceId) external view virtual returns (bool);\n}\n"
    },
    "contracts/utils/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Arithmetic free function collection with operations for fixed-point numbers.\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/FixedPointMath.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n\n/// @dev The multiply-divide operation failed, either due to a\n/// multiplication overflow, or a division by a zero.\nerror MulDivFailed();\n\n/// @dev The maximum possible integer.\nuint256 constant MAX_UINT256 = 2 ** 256 - 1;\n\n/// @dev Returns `floor(x * y / denominator)`.\n/// Reverts if `x * y` overflows, or `denominator` is zero.\nfunction mulDivDown(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 z) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n        if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n            // Store the function selector of `MulDivFailed()`.\n            mstore(0x00, 0xad251c27)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n\n        // Divide x * y by the denominator.\n        z := div(mul(x, y), denominator)\n    }\n}\n\n/// @dev Returns `ceil(x * y / denominator)`.\n/// Reverts if `x * y` overflows, or `denominator` is zero.\nfunction mulDivUp(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 z) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n        if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n            // Store the function selector of `MulDivFailed()`.\n            mstore(0x00, 0xad251c27)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n\n        // If x * y modulo the denominator is strictly greater than 0,\n        // 1 is added to round up the division of x * y by the denominator.\n        z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n    }\n}\n"
    },
    "contracts/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, either due to a\n    /// multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The multiply-divide operation failed, either due to a\n    /// multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The output is undefined, as the input is zero.\n    error Log2Undefined();\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev The maximum possible integer.\n    uint256 internal constant MAX_UINT256 = 2 ** 256 - 1;\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /// -----------------------------------------------------------------------\n    /// Simplified Fixed Point Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                // Store the function selector of `MulWadFailed()`.\n                mstore(0x00, 0xbac65e5b)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                // Store the function selector of `MulWadFailed()`.\n                mstore(0x00, 0xbac65e5b)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                // Store the function selector of `DivWadFailed()`.\n                mstore(0x00, 0x7c5f487d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                // Store the function selector of `DivWadFailed()`.\n                mstore(0x00, 0x7c5f487d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert ExpOverflow();\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-Â½ ln 2, Â½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            if (x <= 0) revert LnWadUndefined();\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Compute k = log2(x) - 96.\n            int256 k;\n            assembly {\n                let v := x\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\n\n                // For the remaining 32 bits, use a De Bruijn lookup.\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\n                v := shr(k, v)\n                v := or(v, shr(1, v))\n                v := or(v, shr(2, v))\n                v := or(v, shr(4, v))\n                v := or(v, shr(8, v))\n                v := or(v, shr(16, v))\n\n                // prettier-ignore\n                k := sub(or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))),\n                    0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)), 96)\n            }\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549â€¦\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// General Number Utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns `floor(x * y / denominator)`.\n    /// Reverts if `x * y` overflows, or `denominator` is zero.\n    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / denominator)`.\n    /// Reverts if `x * y` overflows, or `denominator` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    /// @dev Returns `ceil(x / denominator)`.\n    /// Reverts if `denominator` is zero.\n    function divUp(uint256 x, uint256 denominator) internal pure returns (uint256 z) {\n        assembly {\n            if iszero(denominator) {\n                // Store the function selector of `DivFailed()`.\n                mstore(0x00, 0x65244e4e)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, denominator))), div(x, denominator))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns the square root of `x`.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`.\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, gt(x, 0xffffffffffffffffffffffffffffffffff))\n            r := or(r, shl(6, gt(shr(r, x), 0xffffffffffffffffff)))\n            r := or(r, shl(5, gt(shr(r, x), 0xffffffffff)))\n            r := or(r, shl(4, gt(shr(r, x), 0xffffff)))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns raw remainder of `x / y`.\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns raw `x / y`.\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    /// @dev Returns rounded up output of `x * y` if non-zero modulo.\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) public pure returns (uint256 result) {\n        unchecked {\n            if (x < 11) {\n                // prettier-ignore\n                result = (0x375f0016260009d80004ec0002d00001e0000180000180000200000400001 >> (x * 22)) & 0x3fffff;\n            } else if (x < 32) {\n                result = 3628800;\n                do {\n                    result = result * x;\n                    x = x - 1;\n                } while (x != 10);\n            } else if (x < 58) {\n                // Just cheat lol.\n                result = 8222838654177922817725562880000000;\n                do {\n                    result = result * x;\n                    x = x - 1;\n                } while (x != 31);\n            } else {\n                revert FactorialOverflow();\n            }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        assembly {\n            if iszero(x) {\n                // Store the function selector of `Log2Undefined()`.\n                mstore(0x00, 0x5be3aa5c)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\n            x := shr(r, x)\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n\n            // prettier-ignore\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\n        }\n    }\n\n    /// @dev Returns the averege of `x` and `y`.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(and(x, y), shr(1, xor(x, y)))\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        assembly {\n            let mask := mul(shr(255, x), not(0))\n            z := xor(mask, add(mask, x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        assembly {\n            let a := sub(y, x)\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns gcd of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // prettier-ignore\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue) internal pure returns (uint256 z) {\n        return min(max(x, minValue), maxValue);\n    }\n}\n"
    },
    "contracts/utils/LibBit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Library for bit twiddling operations.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibBit.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\nlibrary LibBit {\n    /// @dev Find last set.\n    /// Returns the index of the most significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `log2(x)`, but without reverting for the zero case.\n    function fls(uint256 x) internal pure returns (uint256 r) {\n        assembly {\n            r := shl(8, iszero(x))\n\n            r := or(r, shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            x := shr(r, x)\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n\n            // prettier-ignore\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\n        }\n    }\n\n    /// @dev Count leading zeros.\n    /// Returns the number of zeros preceding the most significant one bit.\n    /// If `x` is zero, returns 256.\n    function clz(uint256 x) internal pure returns (uint256 r) {\n        r = fls(x);\n        assembly {\n            r := or(and(r, 256), mul(sub(255, r), lt(r, 256)))\n        }\n    }\n\n    /// @dev Find first set.\n    /// Returns the index of the least significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `ctz` (count trailing zeros), which gives\n    /// the number of zeros following the least significant one bit.\n    function ffs(uint256 x) internal pure returns (uint256 r) {\n        assembly {\n            r := shl(8, iszero(x))\n\n            // Isolate the least significant bit.\n            x := and(x, add(not(x), 1))\n\n            r := or(r, shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            // prettier-ignore\n            r := or(r, byte(shr(251, mul(shr(r, x), shl(224, 0x077cb531))), \n                0x00011c021d0e18031e16140f191104081f1b0d17151310071a0c12060b050a09))\n        }\n    }\n\n    /// @dev Returns the number of set bits in `x`.\n    function popCount(uint256 x) internal pure returns (uint256 c) {\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }\n\n    /// @dev Returns whether `x` is a power of 2.\n    function isPo2(uint256 x) internal pure returns (bool result) {\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }\n}\n"
    },
    "contracts/utils/LibBitmap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Efficient bitmap library for mapping integers to single bit booleans.\n/// @author SolDAO (https://github.com/Sol-AO/Solbase/blob/main/src/utils/LibBitmap.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\nlibrary LibBitmap {\n    struct Bitmap {\n        mapping(uint256 => uint256) map;\n    }\n\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\n        // Both cost the same amount of gas, but the former allows the returned value\n        // to be reused without cleaning the upper bits.\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\n        assembly {\n            isSet := b\n        }\n    }\n\n    function set(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\n    }\n\n    function unset(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\n    }\n\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\n        assembly {\n            mstore(0x00, shr(8, index))\n            mstore(0x20, bitmap.slot)\n            let storageSlot := keccak256(0x00, 0x40)\n            let shift := and(index, 0xff)\n            let storageValue := sload(storageSlot)\n\n            let mask := shl(shift, 1)\n            storageValue := xor(storageValue, mask)\n            // It makes sense to return the `newIsSet`,\n            // as it allow us to skip an additional warm `sload`,\n            // and it costs minimal gas (about 15),\n            // which may be optimized away if the returned value is unused.\n            newIsSet := iszero(iszero(and(storageValue, mask)))\n            sstore(storageSlot, storageValue)\n        }\n    }\n\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let storageValue := sload(storageSlot)\n            let shift := and(index, 0xff)\n\n            sstore(\n                storageSlot,\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\n            )\n        }\n    }\n}\n"
    },
    "contracts/utils/LibBytemap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Efficient bytemap library for mapping integers to bytes.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibBytemap.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytemap.sol)\nlibrary LibBytemap {\n    struct Bytemap {\n        mapping(uint256 => uint256) map;\n    }\n\n    function get(Bytemap storage bytemap, uint256 index) internal view returns (uint8 result) {\n        assembly {\n            mstore(0x20, bytemap.slot)\n            mstore(0x00, shr(5, index))\n            result := byte(and(index, 0x1f), sload(keccak256(0x00, 0x20)))\n        }\n    }\n\n    function set(Bytemap storage bytemap, uint256 index, uint8 value) internal {\n        assembly {\n            mstore(0x20, bytemap.slot)\n            mstore(0x00, shr(5, index))\n            let storageSlot := keccak256(0x00, 0x20)\n            // Store the value into the 0x00 slot.\n            mstore(0x00, sload(storageSlot))\n            // And abuse `mstore8` to directly set the byte.\n            mstore8(and(index, 0x1f), value)\n            sstore(storageSlot, mload(0x00))\n        }\n    }\n}\n"
    },
    "contracts/utils/LibClone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Minimal proxy library.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibClone.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\nlibrary LibClone {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// -----------------------------------------------------------------------\n    /// Minimal Proxy Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(0, 0x0c, 0x35)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x21, 0)\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(0, 0x0c, 0x35, salt)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x21, 0)\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of `implementation`,\n    /// with `salt` by `deployer`.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            // prettier-ignore\n            mstore(0x00, 0xff0000000000000000000000602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            // Compute and store the bytecode hash.\n            mstore(0x35, keccak256(0x0c, 0x35))\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Clones with immutable args operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Deploys a minimal proxy with `implementation`,\n    /// using immutable arguments encoded in `data`.\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 108`\n            // The `runSize` is `creationSize - 10`.\n\n            /**\n             * ---------------------------------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\n             * 81         | DUP2              | r 0 r     |                                                       |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\n             * ---------------------------------------------------------------------------------------------------|\n             * RUNTIME (98 bytes + extraLength)                                                                   |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\n             * ---------------------------------------------------------------------------------------------------|\n             *                                                                                                    |\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\n             * 57       | JUMPI          |                          |                                             |\n             * 34       | CALLVALUE      | cv                       |                                             |\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\n             * 5b       | JUMPDEST       |                          |                                             |\n             *                                                                                                    |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\n             *                                                                                                    |\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\n             * ---------------------------------------------------------------------------------------------------+\n             */\n            // Write the bytecode before the data.\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\n            // Write the address of the implementation.\n            mstore(sub(data, 0x0d), implementation)\n            // Write the rest of the bytecode.\n            mstore(sub(data, 0x21), or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73))\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff)\n            mstore(sub(data, 0x5a), or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f))\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            // Create the instance.\n            instance := create(0, sub(data, 0x4c), add(extraLength, 0x6c))\n\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`,\n    /// using immutable arguments encoded in `data`, with `salt`.\n    function cloneDeterministic(\n        address implementation,\n        bytes memory data,\n        bytes32 salt\n    ) internal returns (address instance) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            // Write the bytecode before the data.\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\n            // Write the address of the implementation.\n            mstore(sub(data, 0x0d), implementation)\n            // Write the rest of the bytecode.\n            mstore(sub(data, 0x21), or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73))\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff)\n            mstore(sub(data, 0x5a), or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f))\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            // Create the instance.\n            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)\n\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            // Write the bytecode before the data.\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\n            // Write the address of the implementation.\n            mstore(sub(data, 0x0d), implementation)\n            // Write the rest of the bytecode.\n            mstore(sub(data, 0x21), or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73))\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff)\n            mstore(sub(data, 0x5a), or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f))\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            // Compute and store the bytecode hash.\n            mstore(0x35, keccak256(sub(data, 0x4c), add(extraLength, 0x6c)))\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n}\n"
    },
    "contracts/utils/LibERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC165} from \"./ERC165.sol\";\n\n/// @notice Library used to query support of an interface declared via ERC165.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibERC165.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol)\n/// @dev Note that these functions return the actual result of the query: they do not\n/// revert if an interface is not supported. It is up to the caller to decide\n/// what to do in these cases.\nlibrary LibERC165 {\n    /// @dev As per the ERC165 spec, no interface should ever match `0xffffffff`.\n    bytes4 internal constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /// @dev Returns true if `account` supports the ERC165 interface.\n    function supportsERC165(address account) internal view returns (bool) {\n        return\n            supportsERC165InterfaceUnchecked(account, type(ERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /// @dev Returns true if `account` supports the interface defined by\n    /// `interfaceId`. Support for ERC165 itself is queried automatically.\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /// @notice Query if a contract implements an interface - does not check ERC165 support.\n    /// @param account The address of the contract to query for support of an interface.\n    /// @param interfaceId The interface identifier, as specified in ERC165.\n    /// @return true if the contract at account indicates support of the interface with\n    /// identifier `interfaceId` - false otherwise.\n    /// @dev Assumes that `account` contains a contract that supports ERC165, otherwise\n    /// the behavior of this method is undefined. This precondition can be checked\n    /// with {supportsERC165}.\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // Prepare call.\n        bytes memory encodedParams = abi.encodeWithSelector(ERC165.supportsInterface.selector, interfaceId);\n\n        // Perform static call.\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue != 0;\n    }\n}\n"
    },
    "contracts/utils/LibRLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Library for computing contract addresses from their deployer and nonce.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibRLP.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibRLP.sol)\nlibrary LibRLP {\n    // prettier-ignore\n    function computeAddress(address deployer, uint256 nonce) internal pure returns (address deployed) {\n        // @dev The theoretical allowed limit, based on EIP-2681,\n        // for an account nonce is 2**64-2: https://eips.ethereum.org/EIPS/eip-2681.\n\n        // Caution! This function will NOT check that the nonce is within the theoretical range.\n        // This is for performance, as exceeding the range is extremely impractical.\n        // It is the user's responsibility to ensure that the nonce is valid\n        // (e.g. no dirty bits after packing / unpacking).\n        assembly {\n            // prettier-ignore\n            for {} 1 {} {\n                // The integer zero is treated as an empty byte string,\n                // and as a result it only has a length prefix, 0x80,\n                // computed via `0x80 + 0`.\n\n                // A one-byte integer in the [0x00, 0x7f] range uses its \n                // own value as a length prefix,\n                // there is no additional `0x80 + length` prefix that precedes it.\n                if iszero(gt(nonce, 0x7f)) {\n                    mstore(0x00, deployer)\n                    // Using `mstore8` instead of `or` naturally cleans\n                    // any dirty upper bits of `deployer`.\n                    mstore8(0x0b, 0x94)\n                    mstore8(0x0a, 0xd6)\n                    // `shl` 7 is equivalent to multiplying by 0x80.\n                    mstore8(0x20, or(shl(7, iszero(nonce)), nonce))\n                    deployed := keccak256(0x0a, 0x17)\n                    break\n                }\n                let i := 8\n                // Just use a loop to generalize all the way with minimal bytecode size.\n                // prettier-ignore\n                for {} shr(i, nonce) { i := add(i, 8) } {}\n                // `shr` 3 is equivalent to dividing by 8.\n                i := shr(3, i)\n                // Store in descending slot sequence to overlap the values correctly.\n                mstore(i, nonce)\n                mstore(0x00, shl(8, deployer))\n                mstore8(0x1f, add(0x80, i))\n                mstore8(0x0a, 0x94)\n                mstore8(0x09, add(0xd6, i))\n                deployed := keccak256(0x09, add(0x17, i))\n                break\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/LibSort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Optimized intro sort.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/Sort.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Sort.sol)\nlibrary LibSort {\n    /// @dev Sorts the array in-place.\n    function sort(uint256[] memory a) internal pure {\n        assembly {\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n\n            // Let the stack be the start of the free memory.\n            let stack := mload(0x40)\n\n            // prettier-ignore\n            for {} iszero(lt(n, 2)) {} {\n                // Push `l` and `h` to the stack.\n                // The `shl` by 5 is equivalent to multiplying by `0x20`.\n                let l := add(a, 0x20)\n                let h := add(a, shl(5, n))\n                \n                let j := l\n                // prettier-ignore\n                for {} iszero(or(eq(j, h), gt(mload(j), mload(add(j, 0x20))))) {} {\n                    j := add(j, 0x20)\n                }\n                // If the array is already sorted.\n                // prettier-ignore\n                if eq(j, h) { break }\n\n                j := h\n                // prettier-ignore\n                for {} iszero(or(eq(j, l), gt(mload(j), mload(sub(j, 0x20))))) {} {\n                    j := sub(j, 0x20)\n                }\n                // If the array is reversed sorted.\n                if eq(j, l) { \n                    // prettier-ignore\n                    for {} 1 {} {\n                        let t := mload(l)\n                        mstore(l, mload(h))\n                        mstore(h, t)\n                        h := sub(h, 0x20)\n                        l := add(l, 0x20)\n                        // prettier-ignore\n                        if iszero(lt(l, h)) { break }\n                    }\n                    break\n                }\n\n                // Push `l` and `h` onto the stack.\n                mstore(stack, l)\n                mstore(add(stack, 0x20), h)\n                stack := add(stack, 0x40)\n                break\n            }\n\n            // prettier-ignore\n            for { let stackBottom := mload(0x40) } iszero(eq(stack, stackBottom)) {} {\n                // Pop `l` and `h` from the stack.\n                stack := sub(stack, 0x40)\n                let l := mload(stack)\n                let h := mload(add(stack, 0x20))\n\n                // Do insertion sort if `h - l <= 0x20 * 12`.\n                // Threshold is fine-tuned via trial and error.\n                if iszero(gt(sub(h, l), 0x180)) {\n                    // Hardcode sort the first 2 elements.\n                    let i := add(l, 0x20)\n                    if iszero(lt(mload(l), mload(i))) {\n                        let t := mload(i)\n                        mstore(i, mload(l))\n                        mstore(l, t)\n                    }\n                    // prettier-ignore\n                    for {} 1 {} {\n                        i := add(i, 0x20)\n                        // prettier-ignore\n                        if gt(i, h) { break }\n                        let k := mload(i) // Key.\n                        let j := sub(i, 0x20) // The slot before the current slot.\n                        let v := mload(j) // The value of `j`.\n                        // prettier-ignore\n                        if iszero(gt(v, k)) { continue }\n                        // prettier-ignore\n                        for {} 1 {} {\n                            mstore(add(j, 0x20), v)\n                            j := sub(j, 0x20)\n                            v := mload(j)\n                            // prettier-ignore\n                            if iszero(gt(v, k)) { break }\n                        }\n                        mstore(add(j, 0x20), k)\n                    }\n                    continue\n                }\n                // Pivot slot is the average of `l` and `h`,\n                // rounded down to nearest multiple of 0x20.\n                let p := shl(5, shr(6, add(l, h)))\n                // Median of 3 with sorting.\n                {\n                    let e0 := mload(l)\n                    let e2 := mload(h)\n                    let e1 := mload(p)\n                    if iszero(lt(e0, e1)) {\n                        let t := e0\n                        e0 := e1\n                        e1 := t\n                    }\n                    if iszero(lt(e0, e2)) {\n                        let t := e0\n                        e0 := e2\n                        e2 := t\n                    }\n                    if iszero(lt(e1, e2)) {\n                        let t := e1\n                        e1 := e2\n                        e2 := t\n                    }\n                    mstore(p, e1)\n                    mstore(h, e2)\n                    mstore(l, e0)\n                }\n                // Hoare's partition.\n                {\n                    // The value of the pivot slot.\n                    let x := mload(p)\n                    p := h\n                    // prettier-ignore\n                    for { let i := l } 1 {} {\n                        // prettier-ignore\n                        for {} 1 {} {\n                            i := add(i, 0x20)\n                            // prettier-ignore\n                            if iszero(gt(x, mload(i))) { break }\n                        }\n                        let j := p\n                        // prettier-ignore\n                        for {} 1 {} {\n                            j := sub(j, 0x20)\n                            // prettier-ignore\n                            if iszero(lt(x, mload(j))) { break }\n                        }\n                        p := j\n                        // prettier-ignore\n                        if iszero(lt(i, p)) { break }\n                        // Swap slots `i` and `p`.\n                        let t := mload(i)\n                        mstore(i, mload(p))\n                        mstore(p, t)\n                    }\n                }\n                // If slice on right of pivot is non-empty, push onto stack.\n                {\n                    mstore(stack, add(p, 0x20))\n                    // Skip `mstore(add(stack, 0x20), h)`, as it is already on the stack.\n                    stack := add(stack, shl(6, lt(add(p, 0x20), h)))\n                }\n                // If slice on left of pivot is non-empty, push onto stack.\n                {\n                    mstore(stack, l)\n                    mstore(add(stack, 0x20), p)\n                    stack := add(stack, shl(6, gt(p, l)))\n                }\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    // @dev Sorts the array in-place.\n    function sort(address[] memory a) internal pure {\n        // As any address written to memory will have the upper 96 bits of the\n        // word zeroized (as per Solidity spec), we can directly compare\n        // these addresses as if they are whole uint256 words.\n        uint256[] memory aCasted;\n        assembly {\n            aCasted := a\n        }\n        sort(aCasted);\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    /// For performance, it will not revert if the array is not sorted --\n    /// it will be simply remove consecutive duplicate elements.\n    function uniquifySorted(uint256[] memory a) internal pure {\n        assembly {\n            // If the length of `a` is greater than 1.\n            if iszero(lt(mload(a), 2)) {\n                let x := add(a, 0x20)\n                let y := add(a, 0x40)\n                let end := add(a, shl(5, add(mload(a), 1)))\n                // prettier-ignore\n                for {} 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    y := add(y, 0x20)\n                    // prettier-ignore\n                    if eq(y, end) { break }\n                }\n                mstore(a, shr(5, sub(x, a)))\n            }\n        }\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    /// For performance, it will not revert if the array is not sorted --\n    /// it will be simply remove consecutive duplicate elements.\n    function uniquifySorted(address[] memory a) internal pure {\n        // As any address written to memory will have the upper 96 bits of the\n        // word zeroized (as per Solidity spec), we can directly compare\n        // these addresses as if they are whole uint256 words.\n        uint256[] memory aCasted;\n        assembly {\n            aCasted := a\n        }\n        uniquifySorted(aCasted);\n    }\n\n    /// @dev Returns whether `a` contains `needle`,\n    /// and the index of the nearest element less than or equal to `needle`.\n    function searchSorted(uint256[] memory a, uint256 needle) internal pure returns (bool found, uint256 index) {\n        assembly {\n            let m := 0 // Middle slot.\n            let l := add(a, 0x20) // Slot of the start of search.\n            let h := add(a, shl(5, mload(a))) // Slot of the end of search.\n            // prettier-ignore\n            for {} 1 {} {\n                // Average of `l` and `h`, rounded down to the nearest multiple of 0x20.\n                m := shl(5, shr(6, add(l, h)))\n                found := eq(mload(m), needle)\n                // prettier-ignore\n                if or(gt(l, h), found) { break }\n                // Decide whether to search the left or right half.\n                if iszero(gt(needle, mload(m))) {\n                    h := sub(m, 0x20)\n                    continue\n                }\n                l := add(m, 0x20)   \n            }\n            // `m` will be less than `add(a, 0x20)` in the case of an empty array,\n            // or when the value is less than the smallest value in the array.\n            let t := iszero(lt(m, add(a, 0x20)))\n            index := shr(5, mul(sub(m, add(a, 0x20)), t))\n            found := and(found, t)\n        }\n    }\n}\n"
    },
    "contracts/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibString.sol)\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\n\n    /// -----------------------------------------------------------------------\n    /// Decimal Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Hexadecimal Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for {} 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := add(sub(end, str), 2)\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 0x20)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            let m := add(start, 0xa0)\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := add(sub(end, str), 2)\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 0x20)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\n            // and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\n            str := add(start, 0x60)\n\n            // Allocate the memory.\n            mstore(0x40, str)\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let length := 20\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 32)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, 42)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Other String Operations\n    /// -----------------------------------------------------------------------\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\n    function replace(\n        string memory subject,\n        string memory search,\n        string memory replacement\n    ) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        // prettier-ignore\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            // prettier-ignore\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            // prettier-ignore\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            // Zeroize the slot after the string.\n            let last := add(add(result, 0x20), k)\n            mstore(last, 0)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n            // Store the length of the result.\n            mstore(result, k)\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from) internal pure returns (uint256 result) {\n        assembly {\n            // prettier-ignore\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    // `result = min(from, subjectLength)`.\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)    \n                \n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(add(search, 0x20))\n\n                // prettier-ignore\n                if iszero(lt(subject, subjectSearchEnd)) { break }\n\n                if iszero(lt(searchLength, 32)) {\n                    // prettier-ignore\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        // prettier-ignore\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\n                    }\n                    break\n                }\n                // prettier-ignore\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(\n        string memory subject,\n        string memory search,\n        uint256 from\n    ) internal pure returns (uint256 result) {\n        assembly {\n            // prettier-ignore\n            for {} 1 {} {\n                let searchLength := mload(search)\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) {\n                    from := fromMax\n                }\n                if iszero(mload(search)) {\n                    result := from\n                    break\n                }\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\n\n                subject := add(add(subject, 0x20), from)\n                // prettier-ignore\n                if iszero(gt(subject, subjectSearchEnd)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                // prettier-ignore\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(subjectSearchEnd, 1))\n                        break\n                    }\n                    subject := sub(subject, 1)\n                    // prettier-ignore\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                // prettier-ignore\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    // prettier-ignore\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        // prettier-ignore\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    // prettier-ignore\n                    if iszero(times) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(output, 0)\n                // Store the length.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) {\n                end := subjectLength\n            }\n            if iszero(gt(subjectLength, start)) {\n                start := subjectLength\n            }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                // Copy the `subject` one word at a time, backwards.\n                // prettier-ignore\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := sub(o, 0x20)\n                    // prettier-ignore\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        assembly {\n            if mload(indices) {\n                let indexPtr := add(indices, 0x20)\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n                mstore(sub(indicesEnd, 0x20), mload(subject))\n                mstore(indices, add(mload(indices), 1))\n                let prevIndex := 0\n                // prettier-ignore\n                for {} 1 {} {\n                    let index := mload(indexPtr)\n                    mstore(indexPtr, 0x60)                        \n                    if iszero(eq(index, prevIndex)) {\n                        let element := mload(0x40)\n                        let elementLength := sub(index, prevIndex)\n                        mstore(element, elementLength)\n                        // Copy the `subject` one word at a time, backwards.\n                        // prettier-ignore\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                            o := sub(o, 0x20)\n                            // prettier-ignore\n                            if iszero(o) { break }\n                        }\n                        // Zeroize the slot after the string.\n                        mstore(add(add(element, 0x20), elementLength), 0)\n                        // Allocate memory for the length and the bytes,\n                        // rounded up to a multiple of 32.\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\n                        // Store the `element` into the array.\n                        mstore(indexPtr, element)                        \n                    }\n                    prevIndex := add(index, mload(delimiter))\n                    indexPtr := add(indexPtr, 0x20)\n                    // prettier-ignore\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\n                }\n                result := indices\n                if iszero(mload(delimiter)) {\n                    result := add(indices, 0x20)\n                    mstore(result, sub(mload(indices), 2))\n                }\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory result) {\n        assembly {\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := sub(o, 0x20)\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := sub(o, 0x20)\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes.\n                mload(add(a, 0x1f)),\n                // `length != 0 && length < 32`. Abuses underflow.\n                // Assumes that the length is valid and within the block gas limit.\n                lt(sub(mload(a), 1), 0x1f)\n            )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes of `a` and `b`.\n                or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                // Assumes that the lengths are valid and within the block gas limit.\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\n            )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(add(a, 0x20), mload(a)), 0)\n            // Store the return offset.\n            // Assumes that the string does not start from the scratch space.\n            mstore(sub(a, 0x20), 0x20)\n            // End the transaction, returning the string.\n            return(sub(a, 0x20), add(mload(a), 0x40))\n        }\n    }\n}\n"
    },
    "contracts/utils/MerkleProofLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Gas-optimized verification of proof of inclusion for a leaf in a Merkle tree.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool isValid) {\n        assembly {\n            if proof.length {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(proof.offset, shl(5, proof.length))\n                // Initialize `offset` to the offset of `proof` in the calldata.\n                let offset := proof.offset\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    function verifyMultiProof(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leafs,\n        bool[] calldata flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leafs` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        assembly {\n            // If the number of flags is correct.\n            // prettier-ignore\n            for {} eq(add(leafs.length, proof.length), add(flags.length, 1)) {} {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                // Compute the end calldata offset of `leafs`.\n                let leafsEnd := add(leafs.offset, shl(5, leafs.length))\n                // These are the calldata offsets.\n                let leafsOffset := leafs.offset\n                let flagsOffset := flags.offset\n                let proofOffset := proof.offset\n\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                let hashesBack := hashesFront\n                // This is the end of the memory for the queue.\n                let end := add(hashesBack, shl(5, flags.length))\n\n                // For the case where `proof.length + leafs.length == 1`.\n                if iszero(flags.length) {\n                    // If `proof.length` is zero, `leafs.length` is 1.\n                    if iszero(proof.length) {\n                        isValid := eq(calldataload(leafsOffset), root)\n                        break\n                    }\n                    // If `leafs.length` is zero, `proof.length` is 1.\n                    if iszero(leafs.length) {\n                        isValid := eq(calldataload(proofOffset), root)\n                        break\n                    }\n                }\n\n                // prettier-ignore\n                for {} 1 {} {\n                    let a := 0\n                    // Pops a value from the queue into `a`.\n                    switch lt(leafsOffset, leafsEnd)\n                    case 0 {\n                        // Pop from `hashes` if there are no more leafs.\n                        a := mload(hashesFront)\n                        hashesFront := add(hashesFront, 0x20)\n                    }\n                    default {\n                        // Otherwise, pop from `leafs`.\n                        a := calldataload(leafsOffset)\n                        leafsOffset := add(leafsOffset, 0x20)\n                    }\n\n                    let b := 0\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    switch calldataload(flagsOffset)\n                    case 0 {\n                        // Loads the next proof.\n                        b := calldataload(proofOffset)\n                        proofOffset := add(proofOffset, 0x20)\n                    }\n                    default {\n                        // Pops a value from the queue into `a`.\n                        switch lt(leafsOffset, leafsEnd)\n                        case 0 {\n                            // Pop from `hashes` if there are no more leafs.\n                            b := mload(hashesFront)\n                            hashesFront := add(hashesFront, 0x20)\n                        }\n                        default {\n                            // Otherwise, pop from `leafs`.\n                            b := calldataload(leafsOffset)\n                            leafsOffset := add(leafsOffset, 0x20)\n                        }\n                    }\n                    // Advance to the next flag offset.\n                    flagsOffset := add(flagsOffset, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    // prettier-ignore\n                    if iszero(lt(hashesBack, end)) { break }\n                }\n                // Checks if the last value in the queue is same as the root.\n                isValid := eq(mload(sub(hashesBack, 0x20)), root)\n                break\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Contract that enables a single call to call multiple methods on itself.\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/Multicallable.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\n/// @dev WARNING!\n/// Multicallable is NOT SAFE for use in contracts with checks / requires on `msg.value`\n/// (e.g. in NFT minting / auction contracts) without a suitable nonce mechanism.\n/// It WILL open up your contract to double-spend vulnerabilities / exploits.\n/// See: (https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/)\nabstract contract Multicallable {\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\n    /// If any of the `DELEGATECALL`s reverts, the entire transaction is reverted,\n    /// and the error is bubbled up.\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n        assembly {\n            if data.length {\n                results := mload(0x40) // Point `results` to start of free memory.\n                mstore(results, data.length) // Store `data.length` into `results`.\n                results := add(results, 0x20)\n\n                // `shl` 5 is equivalent to multiplying by 0x20.\n                let end := shl(5, data.length)\n                // Copy the offsets from calldata into memory.\n                calldatacopy(results, data.offset, end)\n                // Pointer to the top of the memory (i.e. start of the free memory).\n                let memPtr := add(results, end)\n                end := add(results, end)\n\n                for {\n\n                } 1 {\n\n                } {\n                    // The offset of the current bytes in the calldata.\n                    let o := add(data.offset, mload(results))\n                    // Copy the current bytes from calldata to the memory.\n                    calldatacopy(\n                        memPtr,\n                        add(o, 0x20), // The offset of the current bytes' bytes.\n                        calldataload(o) // The length of the current bytes.\n                    )\n                    if iszero(delegatecall(gas(), address(), memPtr, calldataload(o), 0x00, 0x00)) {\n                        // Bubble up the revert if the delegatecall reverts.\n                        returndatacopy(0x00, 0x00, returndatasize())\n                        revert(0x00, returndatasize())\n                    }\n                    // Append the current `memPtr` into `results`.\n                    mstore(results, memPtr)\n                    results := add(results, 0x20)\n                    // Append the `returndatasize()`, and the return data.\n                    mstore(memPtr, returndatasize())\n                    returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\n                    // Advance the `memPtr` by `returndatasize() + 0x20`,\n                    // rounded up to the next multiple of 32.\n                    memPtr := and(add(add(memPtr, returndatasize()), 0x3f), 0xffffffffffffffe0)\n                    if iszero(lt(results, end)) {\n                        break\n                    }\n                }\n                // Restore `results` and allocate memory for it.\n                results := mload(0x40)\n                mstore(0x40, memPtr)\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Contract helper for any ERC2612, EIP-4494 or Dai-style token permit.\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/Permit.sol)\nabstract contract Permit {\n    /// @dev ERC20.\n\n    /// @notice Permit to spend tokens for ERC2612 permit signatures.\n    /// @param owner The address of the token holder.\n    /// @param spender The address of the token permit holder.\n    /// @param value The amount permitted to spend.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param v Must produce valid secp256k1 signature from the `owner` along with `r` and `s`.\n    /// @param r Must produce valid secp256k1 signature from the `owner` along with `v` and `s`.\n    /// @param s Must produce valid secp256k1 signature from the `owner` along with `r` and `v`.\n    /// @dev This permit will work for certain ERC721 supporting ERC2612-style permits,\n    /// such as Uniswap V3 position and Solbase NFTs.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual;\n\n    /// @notice Permit to spend tokens for permit signatures that have the `allowed` parameter.\n    /// @param owner The address of the token holder.\n    /// @param spender The address of the token permit holder.\n    /// @param nonce The current nonce of the `owner`.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param allowed If true, `spender` will be given permission to spend `owner`'s tokens.\n    /// @param v Must produce valid secp256k1 signature from the `owner` along with `r` and `s`.\n    /// @param r Must produce valid secp256k1 signature from the `owner` along with `v` and `s`.\n    /// @param s Must produce valid secp256k1 signature from the `owner` along with `r` and `v`.\n    function permit(\n        address owner,\n        address spender,\n        uint256 nonce,\n        uint256 deadline,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual;\n\n    /// @dev ERC721.\n\n    /// @notice Permit to spend specific NFT `tokenId` for ERC2612-style permit signatures.\n    /// @param spender The address of the token permit holder.\n    /// @param tokenId The ID of the token that is being approved for permit.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param v Must produce valid secp256k1 signature from the `owner` along with `r` and `s`.\n    /// @param r Must produce valid secp256k1 signature from the `owner` along with `v` and `s`.\n    /// @param s Must produce valid secp256k1 signature from the `owner` along with `r` and `v`.\n    /// @dev Modified from Uniswap\n    /// (https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/IERC721Permit.sol).\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual;\n\n    /// @notice Permit to spend specific NFT `tokenId` for EIP-4494 permit signatures.\n    /// @param spender The address of the token permit holder.\n    /// @param tokenId The ID of the token that is being approved for permit.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param sig A traditional or EIP-2098 signature.\n    function permit(address spender, uint256 tokenId, uint256 deadline, bytes calldata sig) public virtual;\n\n    /// @dev ERC1155.\n\n    /// @notice Permit to spend multitoken IDs for ERC2612-style permit signatures.\n    /// @param owner The address of the token holder.\n    /// @param operator The address of the token permit holder.\n    /// @param approved If true, `operator` will be given permission to spend `owner`'s tokens.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param v Must produce valid secp256k1 signature from the `owner` along with `r` and `s`.\n    /// @param r Must produce valid secp256k1 signature from the `owner` along with `v` and `s`.\n    /// @param s Must produce valid secp256k1 signature from the `owner` along with `r` and `v`.\n    function permit(\n        address owner,\n        address operator,\n        bool approved,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual;\n}\n"
    },
    "contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Gas-optimized reentrancy protection for smart contracts.\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    error Reentrancy();\n\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        if (locked == 2) revert Reentrancy();\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "contracts/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\nlibrary SafeCastLib {\n    error OverFlow();\n\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        if (x >= (1 << 248)) revert OverFlow();\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        if (x >= (1 << 224)) revert OverFlow();\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        if (x >= (1 << 192)) revert OverFlow();\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        if (x >= (1 << 160)) revert OverFlow();\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        if (x >= (1 << 128)) revert OverFlow();\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        if (x >= (1 << 96)) revert OverFlow();\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        if (x >= (1 << 64)) revert OverFlow();\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        if (x >= (1 << 32)) revert OverFlow();\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        if (x >= (1 << 24)) revert OverFlow();\n\n        y = uint24(x);\n    }\n\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\n        if (x >= (1 << 16)) revert OverFlow();\n\n        y = uint16(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        if (x >= (1 << 8)) revert OverFlow();\n\n        y = uint8(x);\n    }\n}\n"
    },
    "contracts/utils/SafeMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Contract that enables a single call to call multiple methods on itself.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SafeMulticallable.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/Multicallable)\n/// @dev This version of Multicallable removes `payable` to help guard against double-spend vulnerabilities.\nabstract contract SafeMulticallable {\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\n    /// If any of the `DELEGATECALL`s reverts, the entire transaction is reverted,\n    /// and the error is bubbled up.\n    function multicall(bytes[] calldata data) public returns (bytes[] memory results) {\n        assembly {\n            if data.length {\n                results := mload(0x40) // Point `results` to start of free memory.\n                mstore(results, data.length) // Store `data.length` into `results`.\n                results := add(results, 0x20)\n\n                // `shl` 5 is equivalent to multiplying by 0x20.\n                let end := shl(5, data.length)\n                // Copy the offsets from calldata into memory.\n                calldatacopy(results, data.offset, end)\n                // Pointer to the top of the memory (i.e. start of the free memory).\n                let memPtr := add(results, end)\n                end := add(results, end)\n\n                for {\n\n                } 1 {\n\n                } {\n                    // The offset of the current bytes in the calldata.\n                    let o := add(data.offset, mload(results))\n                    // Copy the current bytes from calldata to the memory.\n                    calldatacopy(\n                        memPtr,\n                        add(o, 0x20), // The offset of the current bytes' bytes.\n                        calldataload(o) // The length of the current bytes.\n                    )\n                    if iszero(delegatecall(gas(), address(), memPtr, calldataload(o), 0x00, 0x00)) {\n                        // Bubble up the revert if the delegatecall reverts.\n                        returndatacopy(0x00, 0x00, returndatasize())\n                        revert(0x00, returndatasize())\n                    }\n                    // Append the current `memPtr` into `results`.\n                    mstore(results, memPtr)\n                    results := add(results, 0x20)\n                    // Append the `returndatasize()`, and the return data.\n                    mstore(memPtr, returndatasize())\n                    returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\n                    // Advance the `memPtr` by `returndatasize() + 0x20`,\n                    // rounded up to the next multiple of 32.\n                    memPtr := and(add(add(memPtr, returndatasize()), 0x3f), 0xffffffffffffffe0)\n                    if iszero(lt(results, end)) {\n                        break\n                    }\n                }\n                // Restore `results` and allocate memory for it.\n                results := mload(0x40)\n                mstore(0x40, memPtr)\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/SafeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Safe ETH and ERC20 free function transfer collection that gracefully handles missing return values.\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SafeTransfer.sol)\n/// @author Modified from Zolidity (https://github.com/z0r0z/zolidity/blob/main/src/utils/SafeTransfer.sol)\n\n/// @dev The ETH transfer has failed.\nerror ETHTransferFailed();\n\n/// @dev Sends `amount` (in wei) ETH to `to`.\n/// Reverts upon failure.\nfunction safeTransferETH(address to, uint256 amount) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Transfer the ETH and check if it succeeded or not.\n        if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n            // Store the function selector of `ETHTransferFailed()`.\n            mstore(0x00, 0xb12d13eb)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n\n/// @dev The ERC20 `approve` has failed.\nerror ApproveFailed();\n\n/// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n/// Reverts upon failure.\nfunction safeApprove(address token, address to, uint256 amount) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // We'll write our calldata to this slot below, but restore it later.\n        let memPointer := mload(0x40)\n\n        // Write the abi-encoded calldata into memory, beginning with the function selector.\n        mstore(0x00, 0x095ea7b3)\n        mstore(0x20, to) // Append the \"to\" argument.\n        mstore(0x40, amount) // Append the \"amount\" argument.\n\n        if iszero(\n            and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(eq(mload(0x00), 1), iszero(returndatasize())),\n                // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\n            )\n        ) {\n            // Store the function selector of `ApproveFailed()`.\n            mstore(0x00, 0x3e3f8f73)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n\n        mstore(0x40, memPointer) // Restore the memPointer.\n    }\n}\n\n/// @dev The ERC20 `transfer` has failed.\nerror TransferFailed();\n\n/// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n/// Reverts upon failure.\nfunction safeTransfer(address token, address to, uint256 amount) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // We'll write our calldata to this slot below, but restore it later.\n        let memPointer := mload(0x40)\n\n        // Write the abi-encoded calldata into memory, beginning with the function selector.\n        mstore(0x00, 0xa9059cbb)\n        mstore(0x20, to) // Append the \"to\" argument.\n        mstore(0x40, amount) // Append the \"amount\" argument.\n\n        if iszero(\n            and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(eq(mload(0x00), 1), iszero(returndatasize())),\n                // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\n            )\n        ) {\n            // Store the function selector of `TransferFailed()`.\n            mstore(0x00, 0x90b8ec18)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n\n        mstore(0x40, memPointer) // Restore the memPointer.\n    }\n}\n\n/// @dev The ERC20 `transferFrom` has failed.\nerror TransferFromFailed();\n\n/// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n/// Reverts upon failure.\n///\n/// The `from` account must have at least `amount` approved for\n/// the current contract to manage.\nfunction safeTransferFrom(address token, address from, address to, uint256 amount) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // We'll write our calldata to this slot below, but restore it later.\n        let memPointer := mload(0x40)\n\n        // Write the abi-encoded calldata into memory, beginning with the function selector.\n        mstore(0x00, 0x23b872dd)\n        mstore(0x20, from) // Append the \"from\" argument.\n        mstore(0x40, to) // Append the \"to\" argument.\n        mstore(0x60, amount) // Append the \"amount\" argument.\n\n        if iszero(\n            and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(eq(mload(0x00), 1), iszero(returndatasize())),\n                // We use 0x64 because that's the total length of our calldata (0x04 + 0x20 * 3)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            )\n        ) {\n            // Store the function selector of `TransferFromFailed()`.\n            mstore(0x00, 0x7939f424)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n\n        mstore(0x60, 0) // Restore the zero slot to zero.\n        mstore(0x40, memPointer) // Restore the memPointer.\n    }\n}\n"
    },
    "contracts/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// -----------------------------------------------------------------------\n    /// ETH Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    /// Reverts upon failure.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// ERC20 Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0x095ea7b3)\n            mstore(0x20, to) // Append the \"to\" argument.\n            mstore(0x40, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `ApproveFailed()`.\n                mstore(0x00, 0x3e3f8f73)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0xa9059cbb)\n            mstore(0x20, to) // Append the \"to\" argument.\n            mstore(0x40, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0x23b872dd)\n            mstore(0x20, from) // Append the \"from\" argument.\n            mstore(0x40, to) // Append the \"to\" argument.\n            mstore(0x60, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x64 because that's the total length of our calldata (0x04 + 0x20 * 3)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n}\n"
    },
    "contracts/utils/SelfPermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Permit} from \"./Permit.sol\";\n\n/// @notice Self helper for any ERC2612, EIP-4494 or Dai-style token permit.\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SelfPermit.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/SelfPermit.sol)\n/// @dev These functions are expected to be embedded in multicall to allow EOAs to approve a contract and call a function\n/// that requires an approval in a single transaction.\nabstract contract SelfPermit {\n    /// @dev ERC20.\n\n    /// @notice Permits this contract to spend a given ERC2612 `token` from `owner`.\n    /// @param token The address of the asset spent.\n    /// @param owner The address of the asset holder.\n    /// @param value The amount permitted to spend.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param v Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `s`.\n    /// @param r Must produce valid secp256k1 signature from the `msg.sender` along with `v` and `s`.\n    /// @param s Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `v`.\n    function selfPermit(\n        Permit token,\n        address owner,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        token.permit(owner, address(this), value, deadline, v, r, s);\n    }\n\n    /// @notice Permits this contract to spend a given Dai-style `token` from `owner`.\n    /// @param token The address of the asset spent.\n    /// @param owner The address of the asset holder.\n    /// @param nonce The current nonce of the `owner`.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param v Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `s`.\n    /// @param r Must produce valid secp256k1 signature from the `msg.sender` along with `v` and `s`.\n    /// @param s Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `v`.\n    function selfPermitAllowed(\n        Permit token,\n        address owner,\n        uint256 nonce,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        token.permit(owner, address(this), nonce, deadline, true, v, r, s);\n    }\n\n    /// @dev ERC721.\n\n    /// @notice Permits this contract to spend a given ERC2612-style NFT `tokenID`.\n    /// @param token The address of the asset spent.\n    /// @param tokenId The ID of the token that is being approved for permit.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param v Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `s`.\n    /// @param r Must produce valid secp256k1 signature from the `msg.sender` along with `v` and `s`.\n    /// @param s Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `v`.\n    function selfPermit721(\n        Permit token,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        token.permit(address(this), tokenId, deadline, v, r, s);\n    }\n\n    /// @notice Permits this contract to spend a given EIP-4494 NFT `tokenID`.\n    /// @param token The address of the asset spent.\n    /// @param tokenId The ID of the token that is being approved for permit.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param sig A traditional or EIP-2098 signature.\n    function selfPermit721(Permit token, uint256 tokenId, uint256 deadline, bytes calldata sig) public virtual {\n        token.permit(address(this), tokenId, deadline, sig);\n    }\n\n    /// @dev ERC1155.\n\n    /// @notice Permits this contract to spend a given ERC2612-style multitoken.\n    /// @param token The address of the asset spent.\n    /// @param owner The address of the asset holder.\n    /// @param deadline The unix timestamp before which permit must be spent.\n    /// @param v Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `s`.\n    /// @param r Must produce valid secp256k1 signature from the `msg.sender` along with `v` and `s`.\n    /// @param s Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `v`.\n    function selfPermit1155(\n        Permit token,\n        address owner,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        token.permit(owner, address(this), true, deadline, v, r, s);\n    }\n}\n"
    },
    "contracts/utils/SignatureCheckerLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./ECDSA.sol\";\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\nlibrary SignatureCheckerLib {\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        if (signer == address(0)) return false;\n\n        if (ECDSA.recover(hash, signature) == signer) return true;\n\n        assembly {\n            // Load the free memory pointer.\n            // Simply using the free memory usually costs less if many slots are needed.\n            let m := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(m, 0x1626ba7e) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x20), hash)\n            mstore(add(m, 0x40), 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` and its length over.\n            calldatacopy(add(m, 0x60), sub(signature.offset, 0x20), 0x80)\n\n            isValid := and(\n                and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(0x00), shl(224, mload(m))),\n                    // Whether the returndata is exactly 0x20 bytes (1 word) long .\n                    eq(returndatasize(), 0x20)\n                ),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    add(m, 0x1c), // Offset of calldata in memory.\n                    0xc4, // Length of calldata in memory.\n                    0x00, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n}\n"
    },
    "contracts/utils/SignedWadMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SignedWadMath.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative second amounts, it assumes x is positive.\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\n    assembly {\n        // Multiply x by 1e18 and then divide it by 86400.\n        r := div(mul(x, 1000000000000000000), 86400)\n    }\n}\n\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative day amounts, it assumes x is positive.\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\n    assembly {\n        // Multiply x by 86400 and then divide it by 1e18.\n        r := div(mul(x, 86400), 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Equivalent to require(x == 0 || (x * y) / x == y)\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5 ** 18;\n\n        // Reduce range of x to (-Â½ ln 2, Â½ ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        if (x <= 0) revert(\"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549â€¦\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n"
    },
    "contracts/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\nlibrary SSTORE2 {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    error DeploymentFailed();\n\n    error InvalidPointer();\n\n    error ReadOutOfBounds();\n\n    /// -----------------------------------------------------------------------\n    /// Write Logic\n    /// -----------------------------------------------------------------------\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Note: The assembly block below does not expand the memory.\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, 1)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\n             * 80          | DUP1            | codeSize codeSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\n             * 3D          | RETURNDATASZIE  | 0 codeSize              | [0..codeSize): code |\n             * F3          | RETURN          |                         | [0..codeSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                data,\n                or(\n                    0x61000080600a3d393df300,\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                    shl(0x40, dataSize)\n                )\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Read Logic\n    /// -----------------------------------------------------------------------\n\n    function read(address pointer) internal view returns (bytes memory data) {\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, 1)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            extcodecopy(pointer, add(data, 0x20), 1, size)\n        }\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + 1` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, 1))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            extcodecopy(pointer, add(data, 0x20), add(start, 1), size)\n        }\n    }\n\n    function read(address pointer, uint256 start, uint256 end) internal view returns (bytes memory data) {\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where `end + 1` or `start + 1` overflow.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            extcodecopy(pointer, add(data, 0x20), add(start, 1), size)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}